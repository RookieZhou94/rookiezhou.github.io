<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rookiedev</title>
  
  <subtitle>做好当下每一件事</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gittab.net/"/>
  <updated>2020-08-31T13:08:59.060Z</updated>
  <id>http://gittab.net/</id>
  
  <author>
    <name>rookiedev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最新博客地址：www.gittab.net</title>
    <link href="http://gittab.net/%E6%9C%80%E6%96%B0%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80%EF%BC%9Awww-gittab-net/"/>
    <id>http://gittab.net/最新博客地址：www-gittab-net/</id>
    <published>2020-08-31T13:05:28.000Z</published>
    <updated>2020-08-31T13:08:59.060Z</updated>
    
    <content type="html"><![CDATA[<p>这个博客地址不再维护，最新的博客地址是 <a href="http://www.gittab.net" target="_blank" rel="noopener">www.gittab.net</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个博客地址不再维护，最新的博客地址是 &lt;a href=&quot;http://www.gittab.net&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.gittab.net&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="blog" scheme="http://gittab.net/categories/blog/"/>
    
    
  </entry>
  
  <entry>
    <title>极力推荐的博文排版指南</title>
    <link href="http://gittab.net/%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E7%9A%84%E5%8D%9A%E6%96%87%E6%8E%92%E7%89%88%E6%8C%87%E5%8D%97/"/>
    <id>http://gittab.net/极力推荐的博文排版指南/</id>
    <published>2018-07-23T15:32:52.000Z</published>
    <updated>2018-07-23T15:34:51.017Z</updated>
    
    <content type="html"><![CDATA[<p>作为程序员来说，养成写博客的习惯真的是一件值得去做的事，尽管刚开始可能没有那么高质量的知识输出，但是不是有这样一句话吗？「知识的输入应转化为输出」，也就是说你应该把你所学到的都转化为输出，只有这样你才能更好的掌握你所学的知识，并且在这个过程中你也会对你所学的知识点进行很好的补充。既然要写博文，是不是刚开始就随便写写呢？当然不是，一篇排版好内容不是很好的博文相比于内容好排版很乱的博文能够让人更乐于看下去，尤其是那些对代码有洁癖的程序员我相信你更看不下去，那么以下便是我极力推荐的博客排版指南：</p><h3 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h3><p>「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。」</p><ol><li><p>中英文之间加空格<br>eg. 相信每个程序员都会去全球最大的同性交友网站 GitHub 上逛逛。</p></li><li><p>中文和数字之间加空格<br>eg. 那些排版很乱的博文估计你连 1 分钟都看不下去。</p></li><li><p>数字和单位之间不加空格<br>eg. 现在的安卓手机运行内存没有 6G 都装不了几个应用了。<br>eg. 今天的气温又超过了 40°。<br>eg. 之前买的基金昨天一天跌了 5%。</p></li><li><p>推荐在链接前后加一个空格<br>eg.  我的公众号和博客名称都是 rookiezhou，搜索 rookiezhou 关注我，点击这里 <a href="http://www.rookiezhou.top" target="_blank" rel="noopener">rookiezhou</a> 访问个人博客。</p></li></ol><h3 id="标点符号的细节"><a href="#标点符号的细节" class="headerlink" title="标点符号的细节"></a>标点符号的细节</h3><ol><li><p>不用为了夸张重复使用标点符号<br>eg. 今年法国夺冠了，华帝刚开始打的一手好牌到最后却变成了一副烂牌，你敢信吗？</p></li><li><p>中文段落中尽量使用中文标点符号<br>eg. 一篇好的博文绝对离不开好的排版，所以这篇博文应该算是好文了吧。</p></li><li><p>推荐将引号换成直角引号<br>eg. 你竟然没看过「Java 编程思想」这本书。</p></li><li><p>推荐引号中还有引号替换成直角双引号<br>eg. 经常有人带着疑惑的目光对我说「你竟然没看过『Java 编程思想』这本书？」</p></li><li><p>完整的英文整句使用英文标点符号<br>eg. 引用乔布斯说的那句话：「Stay hungry, stay foolish.」</p></li></ol><h3 id="专有名词大小写尽量规范"><a href="#专有名词大小写尽量规范" class="headerlink" title="专有名词大小写尽量规范"></a>专有名词大小写尽量规范</h3><p>eg. Java、MySQL 都是后端开发人员必须要会的，当然也要会一些前端的技术，比如说：HTML5、CSS、JavaScript、jQuery。</p><p>还有就是对于一些博文可能存在一篇博文下来就只有一段，看起来很紧凑，如果说在每写完一个知识点隔开一行看起来是不是会更好看些呢，这样一来对于我们从小养成的每一段首行空两格的习惯是不是也可以改了呢，其实你去注意一下那些排版比较好的博文，应该大部分都是这么做的，当然这取决于个人，不喜勿喷。</p><p>参考：</p><p><a href="https://www.jianshu.com/p/538faa30b17d" target="_blank" rel="noopener">https://www.jianshu.com/p/538faa30b17d</a><br><a href="https://github.com/mzlogin/chinese-copywriting-guidelines" target="_blank" rel="noopener">https://github.com/mzlogin/chinese-copywriting-guidelines</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为程序员来说，养成写博客的习惯真的是一件值得去做的事，尽管刚开始可能没有那么高质量的知识输出，但是不是有这样一句话吗？「知识的输入应转化为输出」，也就是说你应该把你所学到的都转化为输出，只有这样你才能更好的掌握你所学的知识，并且在这个过程中你也会对你所学的知识点进行很好的
      
    
    </summary>
    
      <category term="写作" scheme="http://gittab.net/categories/%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>正则表达式的基本运用</title>
    <link href="http://gittab.net/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/"/>
    <id>http://gittab.net/正则表达式的基本运用/</id>
    <published>2018-07-18T17:20:57.000Z</published>
    <updated>2018-07-23T13:43:03.049Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式，听起来就很高大上，用起来其实挺复杂的，毕竟人家也算是一门语言，但我们在日常开发中如果会一点正则，你会发现有意想不到的效果，对我们开发的效率还是有一定的提高的。刚开始我一直想学习一下一些简单的正则，但每次看完一些资料当时好像明白怎么回事了，但过一段时间没用又忘了，其实说到底就是自己就根本没掌握好，加上又没去实践，当时理解了，长时间不用自然就忘了。所以说学到的知识需要用起来，这样才能加深理解，也不容易忘记。下面主要说一下正则表达式的简单运用，更加高深的正则可能需要花好些时间去系统的学习一番。</p><p>测试正则表达式是否正确可以去这个网址，下面的测试都是基于它测试出来的，地址如下：</p><p><a href="https://regex101.com/" target="_blank" rel="noopener">正则测试</a></p><h2 id="基本匹配"><a href="#基本匹配" class="headerlink" title="基本匹配"></a>基本匹配</h2><p>这是最简单的正则，也就是平常我们习惯的搜索，根据指定字符去文本中搜索完全匹配的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><blockquote><p>“dee”        ==&gt;    Regular expressions are a <code>dee</code>p language.<br>“deep”    ==&gt;    Regular expressions are a <code>deep</code> language.</p></blockquote><h2 id="正则中的元字符"><a href="#正则中的元字符" class="headerlink" title="正则中的元字符"></a>正则中的元字符</h2><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>点号匹配任意单个字符除了换行符</td></tr><tr><td>[ ]</td><td>字符种类，匹配方括号内的任意字符</td></tr><tr><td>[^]</td><td>否定的字符种类，匹配除了方括号里的字符外其他任意字符</td></tr><tr><td>*</td><td>量词符号，表示 &gt;= 0,即匹配 &gt;=0 个在 * 号前的字符</td></tr><tr><td>+</td><td>量词符号，表示 &gt;= 1,即匹配 &gt;=1 个在 + 号前的字符</td></tr><tr><td>?</td><td>量词符号，表示 &gt;=0,&lt;=1,即 + 号前的字符可出现可不出现</td></tr><tr><td>{n,m}</td><td>大括号之前的字符出现 n 到 m 次</td></tr><tr><td>(abc)</td><td>字符集, 匹配与 xyz 完全相等的字符串</td></tr><tr><td>&#124;</td><td>或运算符,匹配符号前或后的字符</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ &#124;</td></tr><tr><td>^</td><td>从文本的头部开始匹配</td></tr><tr><td>$</td><td>匹配到文本的结尾</td></tr></tbody></table><p>以下面这句话为例，大致说明一下上面表格中的元字符的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><p>1.匹配 e 字符后面接上任意一个字符，包括空格。</p><blockquote><p>“e.”  ==&gt;  R<code>eg</code>ular <code>ex</code>pr<code>es</code>sions ar<code>e</code> a d<code>ee</code>p languag<code>e.</code>  </p></blockquote><p>2.匹配 e 字符后面接上包含在中括号中的任意一个字符。</p><blockquote><p>“e[g,x,e]”  ==&gt;  R<code>eg</code>ular <code>ex</code>pressions are a d<code>ee</code>p language.  </p></blockquote><p>3.匹配 e 字符后面接上不包含在中括号中的任意一个字符，这里需要注意的是中括号中不能既加上包含字符，又加上不包含的字符，也就是不能这样写：”e[g,^x,^e]” 这样匹配出来的结果和上面匹配的结果一致，如果是把不包含的字符写在前面的话：”e[^g,x,e]” 这样匹配的结果则和下面的结果一致。</p><blockquote><p>“e[^g,^x,^e]”  ==&gt;  Regular expr<code>es</code>sions ar<code>e</code> a de<code>ep</code> languag<code>e.</code>  </p></blockquote><p>4.匹配 e 字符后面接上包含中括号中 s 字符任意次，包括 0 次，就是也可以没有字符。</p><blockquote><p>“e[s]*”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>ess</code>ions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p></blockquote><p>5.匹配 e 字符后面接上包含中括号中 s 字符 1次或多次，就是最少要出现一次。</p><blockquote><p>“e[s]+”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p></blockquote><p>6.匹配 e 字符后面接上包含中括号中 s 字符 0 次或 1 次，就是可有可无，注意和第 4 个的区别。</p><blockquote><p>“e[s]?”  ==&gt;  R<code>e</code>gular <code>e</code>xpr<code>es</code>sions ar<code>e</code> a d<code>e</code> <code>e</code>p languag<code>e</code>.</p></blockquote><p>7.匹配 e 字符后面接上包含中括号中 s 字符指定次数，次数在大括号中指定，可以是一个固定数字，也可以是一个范围。</p><blockquote><p>“e[s]{1}”  ==&gt;  Regular expr<code>es</code>sions are a deep language.<br>“e[s]{2,3}”  ==&gt;  Regular expr<code>ess</code>ions are a deep language.</p></blockquote><p>8.匹配 ee 这个字符集出现 1 次到 2 次。</p><blockquote><p>“(ee){1,2}”  ==&gt;  Regular expressions are a d<code>ee</code>p language.</p></blockquote><p>9.匹配 ee 这个字符集出现 1 次到 2 次或者匹配 ss 这个字符集出现 1 次到 2 次。</p><blockquote><p>“(ee){1,2}|ss{1,2}”  ==&gt;  Regular expre<code>ss</code>ions are a d<code>ee</code>p language.</p></blockquote><p>10.匹配 e. 这两个字符，注意这里的点号并不是表示任意字符，经过转义后只是单纯的一个点号。</p><blockquote><p>“e\.”  ==&gt;  Regular expressions are a deep languag<code>e.</code></p></blockquote><p>11.下面第一个表示忽略大小写全局匹配 Re 这个两个字符，第二个表示忽略大小写全局匹配以 Re 开头的字符串。</p><blockquote><p>“Re/gi”  ==&gt;  <code>Re</code>gular exp<code>re</code>ssions a<code>re</code> a deep language.<br> “^Re/gi”  ==&gt;  <code>Re</code>gular expressions are a deep language.</p></blockquote><p>12.下面第一个表示忽略大小写全局匹配 re 加上任意字符，第二个表示忽略大小写全局匹配以 re 加上任意字符结尾的字符串。</p><blockquote><p>“[r,g]e./gi”  ==&gt;  <code>Reg</code>ular exp<code>res</code>sions a<code>re</code> a deep langua<code>ge.</code><br> “[r,g]e.$/gi”  ==&gt;  Regular expressions are a deep langua<code>ge.</code></p></blockquote><h2 id="正则中的简写字符集"><a href="#正则中的简写字符集" class="headerlink" title="正则中的简写字符集"></a>正则中的简写字符集</h2><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字, 等同于 [a-zA-Z0-9_]</td></tr><tr><td>\W</td><td>匹配所有非字母数字, 即符号, 等同于: [^\w]</td></tr><tr><td>\d</td><td>匹配数字: [0-9]</td></tr><tr><td>\D</td><td>匹配非数字: [^\d]</td></tr><tr><td>\s</td><td>匹配所有空格字符, 等同于: [\t\n\f\r\p{Z}]</td></tr><tr><td>\S</td><td>匹配所有非空格字符: [^\s]</td></tr></tbody></table><h2 id="前后关联约束"><a href="#前后关联约束" class="headerlink" title="前后关联约束"></a>前后关联约束</h2><p>1.前置约束存在和前置约束排除：(?=…) 和 (?!…)</p><p>通俗点说就是对指定格式的前面的元素进行约束，前者是匹配到的元素后面跟着指定格式，后者是匹配到的元素后面不是跟着指定格式。结合例子可能更好理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><blockquote><p>“ar(?=\s)” ==&gt;  Regul<code>ar</code> expressions are a deep language //匹配 ar 字符串后面跟着的是空格。<br>“ar(?!\s)” ==&gt;  Regular expressions <code>ar</code>e a deep language//匹配 ar 字符串后面跟着的不是空格。</p></blockquote><p>上面两个正则都是对匹配到的 ar 字符串进行约束，前者是跟着的是空格，后者跟着的不是空格；前者约束存在，书写格式为 (?=…)，后者约束不存在，书写格式为 (?!…)。</p><p>2.后置约束存在和后置约束排除：(?&lt;=…) 和 (?&lt;!…)</p><p>和上面的相对应，对指定格式的后面的元素进行约束，前者是匹配到的元素前面跟着指定格式，后者是匹配到的元素前面不是跟着指定格式。同样结合例子理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><blockquote><p>“(?&lt;=\s)ar”  ==&gt;  Regular expressions <code>ar</code>e a deep language //匹配 ar 字符串前面跟着的是空格。<br>“(?&lt;!\s)ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language//匹配 ar 字符串前面跟着的不是空格。</p></blockquote><p>上面两个正则同样都是对匹配到的 ar 字符串进行约束，前者的前面要是空格，后者的前面要不是空格，同样的前者约束存在，书写格式为 (?&lt;=…)，后者约束不存在，书写格式为 (?&lt;!…)，相比上面多了个小于号。</p><h2 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h2><p>标志也叫修饰语, 它是用来修改表达式的搜索结果. 这些标志可以任意的组合使用, 它也是正则表达式的一部分，常用的标志有三种：g，i，m，分别表示全局搜索，忽略大小写，多行匹配。</p><p>1.全局搜索 g<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><p>匹配测试结果如下：</p><blockquote><p>“ar”  ==&gt;  Regul<code>ar</code> expressions are a deep language<br>“ar/g”  ==&gt;  Regul<code>ar</code> expressions <code>ar</code>e a deep language</p></blockquote><p>上面两者的区别在于第一个是只搜索匹配到的第一个结果，第二个是全局搜索，将所有匹配的结果全部搜索出来。</p><p>2.忽略大小写 i<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><p>匹配测试结果如下：</p><blockquote><p>“Reg”  ==&gt; <code>Reg</code>ular expressions are a deep language<br>“REG/i”  ==&gt; <code>Reg</code>ular expressions are a deep language</p></blockquote><p>上面两者的区别在于第一个是只搜索字符完全匹配的结果，第二个是搜索忽略大小写的匹配结果。</p><p>3.多行匹配 m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg. Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language,</span><br><span class="line">Regular expressions are a deep language.</span><br></pre></td></tr></table></figure></p><p>“^Reg/g” 匹配结果如下：</p><blockquote><p><code>Reg</code>ular expressions are a deep language,<br>Regular expressions are a deep language,<br>Regular expressions are a deep language.</p></blockquote><p>“^Reg/gm” 匹配结果如下：</p><blockquote><p><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language,<br><code>Reg</code>ular expressions are a deep language.</p></blockquote><p>这样一对比两者的区别其实就已经出来了，第一个是全局搜索匹配到的结果，匹配的是第一行的开头，而第二个也是全局搜索匹配到的结果，只不过它是匹配每一行的开头。</p><p>以上就是正则表达式的一些基础运用，有了上面的基础，然后在平常开发中积极去尝试写出一些稍微复杂的正则，加强练习，不然只会像我刚开始一样，看完之后过一段时间就忘了，只有不断练习，慢慢的才会对正则有一些感觉。这些正则的基础也是我在 github 上找到一个关于学习正则的项目，然后通过这个项目的学习所掌握的，下面就是这个项目的地址：</p><p><a href="https://github.com/zeeshanu/learn-regex" target="_blank" rel="noopener">学习正则表达式</a></p><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">整数: ^-?\d+$</span><br><span class="line">正整数: ^\d+$</span><br><span class="line">负整数: ^-\d+$`</span><br><span class="line">纯小写字母: ^([a-z])*$</span><br><span class="line">纯大写字母: ^([A-Z])*$</span><br><span class="line">用户名: ^[\w\d_.]&#123;4,16&#125;$</span><br><span class="line">数字和英文字母: ^[a-zA-Z0-9]*$</span><br><span class="line">数字和英文字母和空格: ^[a-zA-Z0-9 ]*$</span><br><span class="line">密码: ^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</span><br><span class="line">邮箱: ^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</span><br><span class="line">IP4 地址: ^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</span><br><span class="line">URL: ^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正则表达式，听起来就很高大上，用起来其实挺复杂的，毕竟人家也算是一门语言，但我们在日常开发中如果会一点正则，你会发现有意想不到的效果，对我们开发的效率还是有一定的提高的。刚开始我一直想学习一下一些简单的正则，但每次看完一些资料当时好像明白怎么回事了，但过一段时间没用又忘了，
      
    
    </summary>
    
      <category term="正则表达式" scheme="http://gittab.net/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>zookeeper 单机模式以及伪集群模式搭建</title>
    <link href="http://gittab.net/zookeeper-%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%90%AD%E5%BB%BA/"/>
    <id>http://gittab.net/zookeeper-单机模式以及伪集群模式搭建/</id>
    <published>2018-07-16T14:32:57.000Z</published>
    <updated>2018-07-23T13:43:02.325Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下我对 <code>zookeeper</code> 的学习，在刚开始听的时候觉得很高大上，但又觉得很陌生，也不知道是干嘛的，然后就网上查各种资料开始慢慢对 <code>zookeeper</code> 好像有点感觉了，又好像还是似懂非懂的样子，然后还看到网上都在告诉我们 <code>zookeeper</code> 的安装以及 <code>zookeeper</code> 集群的搭建，又尝试着去搭建了一遍。到最后还是有点晕乎乎的样子，总觉得好像不是很理解，包括网上说的 <code>zookeeper</code> 一些使用场景。</p><p>通过这些过程下来，我有点觉得刚开始既然不是很理解，那么就先不去理解它，不要尝试着钻牛角尖，为何不先试着在实践中动手接触它，感受它，在这之后有点感觉之后我们再去理解 <code>zookeeper</code> 背后的那些原理会不会更好一点呢？当然这只是个人看法，因人而异，如果有类似感觉的不防这样试试。那么接下来我就先说说 <code>zookeeper</code> 的安装以及搭建过程。</p><h2 id="zookeeper-下载解压"><a href="#zookeeper-下载解压" class="headerlink" title="zookeeper 下载解压"></a>zookeeper 下载解压</h2><p>在测试之前先说一下，zookeeper 的运行需要依赖 Java 运行环境，所以先要保证你安装好了 Java 环境。接下来下载 zookeeper 的最新稳定版 <code>zookeeper-3.4.12</code> 进行测试，下载链接如下：</p><p><a href="http://mirrors.shu.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz" target="_blank" rel="noopener">zookeeper-3.4.12 下载链接</a></p><p>由于本人使用的是 Ubuntu 16.04 系统版本，所以下面的测试也是基于该系统下进行测试的，当然在 Window 系统下步骤也是一样的，只是执行的方式不一样而已。将上面下载好的文件进行解压，最好解压到你常用的安装软件目录下，以便后面查找 zookeeper 配置文件的位置，当然如果说你知道你自己所放的位置那也无所谓了，当然我还是比较推荐把我们平常开发中常用的软件单独建一个文件夹保存，这样可以让我们的电脑文件不会显得很乱，后面的查找效率也会高很多。回到正题，下面是 zookeeper 的解压命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf zookeeper-3.4.12.tar.gz -C /home/zhouxh/software/</span><br></pre></td></tr></table></figure><h2 id="zookeeper-单机搭建"><a href="#zookeeper-单机搭建" class="headerlink" title="zookeeper 单机搭建"></a>zookeeper 单机搭建</h2><p>解压好之后，记住你解压之后存放的位置，比如我上面，我存放在 /home/zhouxh/software/ 目录下面，接下来就切到该目录下的 zookeeper-3.4.12 目录下，里面有一个 conf 的目录，继续 cd 到 conf 目录下，这个目录存放的就是 zookeeper 运行时需要的配置文件，这里我们先将里面的 zoo_sample.cfg 文件拷贝一份并且重命名为 zoo.cfg，然后编辑 zoo.cfg 文件，这里我们先不说文件中的各项配置是什么含义，先照着做就可以了，到后面会详细解释，打开 zoo.cfg 文件，在里面修改 dataDir 配置然后再加上 dataLogDir 配置，该文件的全部配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">#dataDir=/tmp/zookeeper</span><br><span class="line">dataDir=/home/zhouxh/software/zookeeper-3.4.12/data</span><br><span class="line">dataLogDir=/home/zhouxh/software/zookeeper-3.4.12/logs</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br></pre></td></tr></table></figure></p><p>上面配置文件中修改和添加的这两项配置都有一个路径，也就是刚才解压的 zookeeper 文件所在路径，在 zookeeper 的目录下创建两个文件夹：data 和 logs，创建好之后单机模式的 zookeeper 文件配置就已经配置好了，然后我们就可以运行了，为了运行方便，最好我们把 zookeeper 命令路径配置到环境变量中去，这样我们就不用每次执行都切换到 zookeeper 目录下的 bin 目录中去，如果没配那就到 zookeeper 的 bin 目录下去执行命令，启动命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure></p><p>启动完成之后再执行查看 zookeeper 的运行状态的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure></p><p><img src="zookeeper 单机模式以及伪集群模式搭建/zk-start.png" alt="运行结果如下"></p><p>也可以通过客户端命令来连接 zookeeper 服务来判断是否启动成功，如果是 zookeeper 是在本机上那么直接执行以下命令就好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh</span><br></pre></td></tr></table></figure><p>如果是跨机器连接的话则需要加参数，-server 后面加上要连的服务 IP 和端口，IP 是你要连的 zookeeper 服务所在机器的 IP，端口就是刚才 zoo.cfg 中的 clientPort=2181 配置的端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure></p><p><img src="zookeeper 单机模式以及伪集群模式搭建/zoo-cli.png" alt="运行结果如下"></p><p>连接成功之后我们就可以对 zookeeper 服务上的节点以及节点中的数据进行增删改查了，这里提一下，zookeeper 中的节点结构类似于 Linux 系统下的文件路径，都是树形结构。到这里单机模式的搭建就已经完了，接下来我们再尝试着搭建 zookeeper 伪集群模式。</p><h2 id="zookeeper-伪集群搭建"><a href="#zookeeper-伪集群搭建" class="headerlink" title="zookeeper 伪集群搭建"></a>zookeeper 伪集群搭建</h2><p>有了之前单机模式下搭建过程，伪集群其实也差不多，之所以说是伪集群，是因为是在同一台电脑上模拟出来的多台服务，这里以三台为例进行模拟搭建，当然如果你条件够宽裕，也可以直接在三台电脑上进行搭建，当然这三台电脑需要互相可访问，因为他们之间需要通信。下面是在单台电脑上搭建伪集群的过程：</p><p>首先我们将之前用到的 zoo.cfg 拷贝三份放在 conf 目录下，分别命名为 zoo1.cfg，zoo2.cfg，zoo3.cfg，然后分别修改这三个文件，下面我先贴出第一个服务 zoo1.cfg 的配置内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir=/home/zhouxh/software/zookeeper-3.4.12/data1</span><br><span class="line">dataLogDir=/home/zhouxh/software/zookeeper-3.4.12/log1</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval=1</span><br><span class="line">server.1=192.168.1.108:2881:3881</span><br><span class="line">server.2=192.168.1.108:2882:3882</span><br><span class="line">server.3=192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure></p><p>其他两个文件只需要修改其中一个客户端端口和两个路径就好，其他的和上面配置内容一致。<br>zoo2.cfg 不同部分配置内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/zhouxh/software/zookeeper-3.4.12/data2</span><br><span class="line">dataLogDir=/home/zhouxh/software/zookeeper-3.4.12/log2</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2182</span><br></pre></td></tr></table></figure></p><p>zoo3.cfg 不同部分配置内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/home/zhouxh/software/zookeeper-3.4.12/data3</span><br><span class="line">dataLogDir=/home/zhouxh/software/zookeeper-3.4.12/log3</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2183</span><br></pre></td></tr></table></figure></p><p>看了上面三个文件的配置内容，我们应该能猜到接下来我们还需要在对应路径下创建几个文件夹，分别是：data1，data2，data3 以及 log1，log2，log3，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/zhouxh/software/zookeeper-3.4.12/data1</span><br><span class="line">/home/zhouxh/software/zookeeper-3.4.12/data2</span><br><span class="line">/home/zhouxh/software/zookeeper-3.4.12/data3</span><br><span class="line"></span><br><span class="line">/home/zhouxh/software/zookeeper-3.4.12/log1</span><br><span class="line">/home/zhouxh/software/zookeeper-3.4.12/log2</span><br><span class="line">/home/zhouxh/software/zookeeper-3.4.12/log3</span><br></pre></td></tr></table></figure></p><p>同时我们还注意到每个配置文件都多了一小部分内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.1.108:2881:3881</span><br><span class="line">server.2=192.168.1.108:2882:3882</span><br><span class="line">server.3=192.168.1.108:2883:3883</span><br></pre></td></tr></table></figure></p><p>这部分内容中 server 后面的那个数字是区分各个不同服务的，这个数字还需要在我们刚才新建的那三个文件夹 data1，data2，data3 下面分别新建三个文件，文件名为 myid，这个文件就只写入这个数字就好，也就是 data1 目录下的文件 myid 内容为 1，data2 目录下的文件 myid 内容为 2，data3 目录下的文件 myid 内容为 3，当然如果是三台不同的机器的话，就是把刚才创建三份的文件夹以及文件在每台机器上配置一份就好，内容可以不变，端口那些可以自己定，也可以完全按照上面的方式配置。到这里配置部分就结束了，接下来我们就可以测试我们的配置是否正确了。</p><p>首先我们依次将三个 zookeeper 服务分别启动起来，每启动一台查看一下当前启动的 zookeeper 的运行状态，切换到 zookeeper 的 bin 目录下进行启动，启动命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start ~/software/zookeeper-3.4.12/conf/zoo1.cfg</span><br><span class="line">./zkServer.sh status ~/software/zookeeper-3.4.12/conf/zoo1.cfg</span><br></pre></td></tr></table></figure></p><p>上面将第一台 zookeeper 服务先启动，启动后紧接着查看其运行状态发现会报如下一个错。</p><p><img src="zookeeper 单机模式以及伪集群模式搭建/zoo1-start.png" alt="运行结果如下"></p><p>这是由于其他两台还没启动，所以我们先不管，继续启动另外两台服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start ~/software/zookeeper-3.4.12/conf/zoo2.cfg</span><br><span class="line">./zkServer.sh status ~/software/zookeeper-3.4.12/conf/zoo1.cfg</span><br><span class="line"></span><br><span class="line">./zkServer.sh start ~/software/zookeeper-3.4.12/conf/zoo3.cfg</span><br><span class="line">./zkServer.sh status ~/software/zookeeper-3.4.12/conf/zoo3.cfg</span><br></pre></td></tr></table></figure></p><p>不出意外的话，当启动第二台后再查看第一台服务状态时会打印如下信息：</p><p><img src="zookeeper 单机模式以及伪集群模式搭建/zoo2-start.png" alt="运行结果如下"></p><p>这表明我们已经启动成功了，继续启动第三台就好，当三台全部启动成功后说明我们的伪集群搭建成功了。</p><p>我们也可以尝试用 zkCli.sh 命令去连接这个集群看看能不能连上，由于这三台已经是集群模式，我们任意连接其中一台都是一样的，以连接第一台为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>出现如下信息表示连接成功:</p><p><img src="zookeeper 单机模式以及伪集群模式搭建/zoo-client.png" alt="运行结果如下"></p><p>上面就是我们搭建的整个过程，搭建完成后最好回顾一下，如果中间遇到什么问题可以直接网上搜索，肯定能找到的，现在我们只是初步了解了 zookeeper 服务的搭建过程，具体这些配置文件中的含义以及为什么要搭建集群，为什么选择三台进行模拟集群，这样做有什么好处；还有就是 zookeeper 到底应该怎么用，哪些情况下需要用到 zookeeper，下一篇将会详细介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先说一下我对 &lt;code&gt;zookeeper&lt;/code&gt; 的学习，在刚开始听的时候觉得很高大上，但又觉得很陌生，也不知道是干嘛的，然后就网上查各种资料开始慢慢对 &lt;code&gt;zookeeper&lt;/code&gt; 好像有点感觉了，又好像还是似懂非懂的样子，然后还看到网上都在告
      
    
    </summary>
    
      <category term="zookeeper" scheme="http://gittab.net/categories/zookeeper/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx location 路径匹配规则</title>
    <link href="http://gittab.net/nginx-location-%E8%B7%AF%E5%BE%84%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/"/>
    <id>http://gittab.net/nginx-location-路径基本匹配规则/</id>
    <published>2018-07-10T15:10:20.000Z</published>
    <updated>2018-07-23T13:43:01.673Z</updated>
    
    <content type="html"><![CDATA[<p>之前每次配置 nginx 中的 location 这个路径时都会很头疼，基本上每次都是靠碰运气，一个个去试，直到访问路径通了为止，这样一来到最后还是不知道怎么配置成功的，下次再配置时又需要一个个去试，既浪费时间又很没有效率，所以这次特意花了点时间去学习了一番，特此记录一下，也记录一下自己在测试的过程中踩过的一些坑。</p><h2 id="location-匹配模式"><a href="#location-匹配模式" class="headerlink" title="location 匹配模式"></a>location 匹配模式</h2><p>主要有以下几种匹配模式：</p><ul><li>= 绝对匹配，如果匹配到了这个将停止匹配并处理该请求</li><li>~ 区分大小写的正则匹配</li><li>~* 不区分大小写的正则匹配</li><li>^~ 如果把这个前缀用于一个常规字符串,那么告诉 nginx 如果路径匹配那么不再去匹配正则</li><li>/ 通用匹配，任何请求都会匹配到</li></ul><p>它们之间的匹配顺序为：<br>1.先匹配普通字符串，然后再匹配正则表达式。<br>2.一般情况下，匹配成功了普通字符串 location 后还会进行正则表达式的 location 匹配。当然有两种方法能够改变这种方式，一个是使用 = 进行绝对匹配，另一个则是使用 ^~ 前缀匹配，它在匹配到了普通字符 location 之后不会再去寻找正则匹配。<br>3.普通字符串匹配顺序是根据配置中的字符长度从长到短，也就是使用普通字符串的匹配顺序和 location 之间的先后顺序是无关的，最后 nginx 都会根据配置的字符长短来进行匹配。<br>4.正则表达式则是按照配置文件里的顺序来匹配，找到第一个匹配的正则表达式将停止搜索。</p><p>下面列举常见的几个匹配模式，在测试的过程中注意缓存的原因导致测试结果不正确，优先使用 Firefox 浏览器测试，Chrome 浏览器的缓存更严重。最好的还是每次测试访问时先清除一下缓存，这样才能保证我们的测试结果是正确的。还一个就是注意地址是否填写正确，不要在地址栏最后多出一个斜杠。最后就是我们所编辑的 nginx 配置文件一定要和我们启动的 nginx 配置文件一致。</p><h2 id="绝对匹配"><a href="#绝对匹配" class="headerlink" title="绝对匹配"></a>绝对匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    proxy_pass http://192.168.0.234:10080/index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的绝对匹配只是简单的配置了一个代理，将当前路径代理到另外一个服务的首页。</p><h2 id="区分大小写的正则匹配"><a href="#区分大小写的正则匹配" class="headerlink" title="区分大小写的正则匹配"></a>区分大小写的正则匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ image &#123;</span><br><span class="line">    root /home/zhouxh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置表示当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg" target="_blank" rel="noopener">http://192.168.0.234:10080/image/test.jpg</a> 时，将会转到当前服务的 /home/zhouxh/image/ 目录下去查找 test.jpg，也就是 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg。" target="_blank" rel="noopener">http://192.168.0.234:10080/home/zhouxh/image/test.jpg。</a></p><h2 id="通用匹配"><a href="#通用匹配" class="headerlink" title="通用匹配"></a>通用匹配</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">    root /home/zhouxh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于配置比较简单，上面的配置和上一个正则匹配的结果是一样的，只不过这里是通过普通的匹配方式匹配到 /image 这个 location。</p><h2 id="location-中的-root-和-alias-的区别"><a href="#location-中的-root-和-alias-的区别" class="headerlink" title="location 中的 root 和 alias 的区别"></a>location 中的 root 和 alias 的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">    root /home/zhouxh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /image &#123;</span><br><span class="line">    alias /home/zhouxh/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的两个配置当用户访问 <a href="http://192.168.0.234:10080/image/test.jpg" target="_blank" rel="noopener">http://192.168.0.234:10080/image/test.jpg</a> 时，访问的文件路径是不一样的，当使用 root 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/image/test.jpg，当使用" target="_blank" rel="noopener">http://192.168.0.234:10080/home/zhouxh/image/test.jpg，当使用</a> alias 时路径为 <a href="http://192.168.0.234:10080/home/zhouxh/test.jpg，两者的区别在于" target="_blank" rel="noopener">http://192.168.0.234:10080/home/zhouxh/test.jpg，两者的区别在于</a> root 是将实际访问文件路径即 root 后面的路径拼接 URL 中的路径，而 alias 是实际访问文件路径即 alias 后面的路径不去拼接 URL 中的路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前每次配置 nginx 中的 location 这个路径时都会很头疼，基本上每次都是靠碰运气，一个个去试，直到访问路径通了为止，这样一来到最后还是不知道怎么配置成功的，下次再配置时又需要一个个去试，既浪费时间又很没有效率，所以这次特意花了点时间去学习了一番，特此记录一下，
      
    
    </summary>
    
      <category term="nginx" scheme="http://gittab.net/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx 实现 TCP 代理及其负载均衡之 stream 模块</title>
    <link href="http://gittab.net/nginx-%E5%AE%9E%E7%8E%B0-TCP-%E4%BB%A3%E7%90%86%E5%8F%8A%E5%85%B6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B9%8B-stream-%E6%A8%A1%E5%9D%97/"/>
    <id>http://gittab.net/nginx-实现-TCP-代理及其负载均衡之-stream-模块/</id>
    <published>2018-07-04T15:10:05.000Z</published>
    <updated>2018-07-23T13:43:02.269Z</updated>
    
    <content type="html"><![CDATA[<p>前面所说的 nginx 负载均衡都是基于 HTTP 七层代理，有时候我们可能需要基于 TCP 四层代理以及负载均衡，在之前我们可能需要编译安装第三方的一个模块 nginx_tcp_proxy_module，并且需要打上一个补丁，具体安装方式可以去参考项目中的描述，项目地址如下，不过需要注意的是安装这个模块存在兼容性问题，最好使用较低版本的 nginx 去安装，否则很容易出错，所以现在不推荐使用这个进行 TCP 代理。在 nginx 1.9.0 的版本以及更高的版本中，nginx 默认将 ngx_stream_core_module 模块编译进来了，该模块支持 TCP 代理及其负载均衡。下面就主要来介绍一下如何使用它来进行 TCP 代理和负载均衡。</p><p><a href="https://github.com/yaoweibin/nginx_tcp_proxy_module" target="_blank" rel="noopener">nginx_tcp_proxy_module 项目地址</a></p><h2 id="ngx-stream-core-module-编译安装"><a href="#ngx-stream-core-module-编译安装" class="headerlink" title="ngx_stream_core_module 编译安装"></a>ngx_stream_core_module 编译安装</h2><p>由于 nginx 1.9.0 版本以及之后的版本默认将该模块集成进来了，所以我们不需要额外添加，我们只需要在配置时加上 –with-stream 参数来激活这个模块。命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --with-stream</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><h2 id="TCP-代理"><a href="#TCP-代理" class="headerlink" title="TCP 代理"></a>TCP 代理</h2><p>将 nginx 配置安装好了之后就可以在 nginx.conf 的配置文件中配置 TCP 代理了，其实也就是在配置文件在加一个和 http 模块平级的 stream 模块，其他配置大部分和 http 代理中的一样，下面是一个简单的 TCP 代理配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50001;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.110:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 50002;</span><br><span class="line">        proxy_connect_timeout 1s;</span><br><span class="line">        proxy_timeout 3s;</span><br><span class="line">        proxy_pass 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是监听本机的 50001 和 50002 端口，并且将其分别代理到 192.168.1.110 和 192.168.1.111 的 10080 端口，而 10080 这个端口 分别是 192.168.1.110 和 192.168.1.111 的 nginx 访问端口，测试情况如下图：</p><p><img src="nginx-实现-TCP-代理及其负载均衡之-stream-模块/tcp_proxy.png" alt="测试结果"></p><h2 id="TCP-负载均衡"><a href="#TCP-负载均衡" class="headerlink" title="TCP 负载均衡"></a>TCP 负载均衡</h2><p>基于 TCP 的负载均衡和 HTTP 的负载均衡配置大致一样，只不过负载均衡策略没有那么多，主要有默认的轮询，加权轮询，最少连接数，最低平均延时，hash 这五种方式，先声明以下测试是在 nginx 版本 1.12.0 上测试的。这里简单说一下我所遇到的坑，我刚开始是在 chrome 浏览器上测试的，发现测试这些策略都是不对的，而且始终访问到后台同一台服务，只是偶尔会变一下，然后使用 Firefox 浏览器测试，发现按 F5 刷新还是始终访问到同一后台服务，然后尝试着按 Ctrl + F5 进行刷新这才按照我们配置的策略进行负载，而回到 chrome 浏览器上也试着按 Ctrl + F5 刷新还是一直访问的后台同一台服务，暂时还不知道是什么原因。有知道的可以告诉我一下，不甚感激。</p><p>1.默认配置 ( 轮询 )</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置就是不加任何负载策略，采用默认的方式，默认的方式就是轮询的方式。</p><p>2.加权轮询配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        server 192.168.1.110:10080 weight=3;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是在轮询策略的基础上给每个后台服务加上权重，权重越大，访问的概率越大，像上面的配置的话就是每访问三次 192.168.1.110 这台服务就会访问一次 192.168.1.111 这台服务。</p><p>3.最少连接数配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是采用一种固定的负载策略，最少连接数策略，也就是选择连接数最少的后台服务。</p><p>4.最低平均延时配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        least_time connect;</span><br><span class="line">        #least_time first_byte;</span><br><span class="line">        #least_time last_byte;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面策略配置表示的是对于每个请求，可通过最低平均延时来选择后台服务，而这个最低平均延时则是看 least_time 指令中指定的参数计算出来的，主要有下面三个参数：</p><ul><li>connect：连接到后台服务花的时间</li><li>first_byte：接收到第一个字节花的时间</li><li>last_byte：接收到最后一个字节花的时间，也就是全部接收完的时间</li></ul><p>值得注意的是该策略现在是作为 nginx 商业订阅的一部分提供，也就是需要花钱才能够实现这个功能。</p><p>5.hash 配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream loadserver &#123;</span><br><span class="line">        hash $remote_addr consistent;</span><br><span class="line">        server 192.168.1.110:10080;</span><br><span class="line">        server 192.168.1.111:10080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8000;  # 需要监听的端口</span><br><span class="line">        proxy_pass loadserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面采用的是 hash 算法策略，对客户端的 IP 进行 hash，让每台客户端固定访问到后台的一台服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面所说的 nginx 负载均衡都是基于 HTTP 七层代理，有时候我们可能需要基于 TCP 四层代理以及负载均衡，在之前我们可能需要编译安装第三方的一个模块 nginx_tcp_proxy_module，并且需要打上一个补丁，具体安装方式可以去参考项目中的描述，项目地址如
      
    
    </summary>
    
      <category term="nginx" scheme="http://gittab.net/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx 负载均衡策略之第三方扩展策略</title>
    <link href="http://gittab.net/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E6%89%A9%E5%B1%95%E7%AD%96%E7%95%A5/"/>
    <id>http://gittab.net/nginx-负载均衡策略之第三方扩展策略/</id>
    <published>2018-07-03T14:51:01.000Z</published>
    <updated>2018-07-23T13:43:03.677Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经将 nginx 负载均衡中的内置策略介绍完了，下面我们来看一下第三方的扩展策略，所谓的内置策略其实就是 nginx 安装后就已经自带了，对于第三方的一些策略则是需要我们在安装时要额外添加第三方的模块才能实现。下面就一一进行介绍：</p><h2 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h2><p>该策略将前端请求的 url 地址进行 hash，根据 hash 结果将请求定向到同一后端服务器节点上，这种适合后台服务器为缓存时比较有效，一般也会配合缓冲命中来使用。</p><p>刚才也说了第三方策略需要额外添加第三方模块才能实现，所以我们需要对我们的 nginx 进行重新编译安装，下面是添加第三方模块编译安装的命令，但要注意的是这个第三方模块需要我们提前下载好，下面命令中的路径就是我下载的模块所在路径。url_hash 策略需要的第三方模块是 ngx_http_consistent_hash，这个可以在 nginx 第三方模块网站中找到该项目的 github 地址，这里贴出地址：</p><p><a href="https://www.nginx.com/resources/wiki/modules/" target="_blank" rel="noopener">nginx 第三方模块网站</a><br><a href="https://github.com/replay/ngx_http_consistent_hash" target="_blank" rel="noopener">ngx_http_consistent_hash 项目地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --add-module=/home/zhouxh/software/ngx_http_consistent_hash</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>然后还是在之前我们添加的 upstream 中加上对应的策略，配置如下，不清楚的可以参考上一篇的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    consistent_hash $request_uri;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的配置加了一个调度策略：一致性哈希 consistent_hash，对客户端请求的 url 进行哈希，既然这里采用 url_hash 的策略来进行负载，那么对于后面再进行权重配置就没有多大意义了，所以后面就不必再添加 weight 权重配置了。</p><h2 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h2><p>这个策略按后端服务器的响应时间来分配请求，响应时间短的优先分配，但在实际项目中，响应时间受很多的因素所影响，所以真正采用这种方式进行负载需慎重。同样的先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 项目地址如下：</p><p><a href="https://github.com/itoffshore/nginx-upstream-fair" target="_blank" rel="noopener">nginx-upstream-fair 项目地址</a></p><p>这个项目其实并不是第三方模块网站中找到的那个 nginx-upstream-fair 项目，那个项目我使用 nginx-1.12.0 版本的 nginx 编译出错，于是看到那个项目中也有人遇到这个问题，他推荐的是另一个 nginx-upstream-fair 项目，也就是上面贴出来的那个，编译正常通过，基于 nginx-1.12.0 版本的 nginx 亲测可用。<br>编译安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --add-module=/home/zhouxh/software/ngx_http_consistent_hash --add-module=/home/zhouxh/software/nginx-upstream-fair</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>配置也是一样的，只是需要改变一下策略名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>该策略是在多台服务器的环境下，确保一个客户端只和一台服务器通讯，它会保持长连接，并在结束会话后再次选择一个服务器，保证了压力均衡。同样的我们先下载 fair 策略对应的第三方模块 nginx-upstream-fair，再对我们的 nginx 进行重新编译安装，nginx-upstream-fair 模块在第三方模块网站中能够找到直接下载：</p><p><a href="https://www.nginx.com/resources/wiki/modules/" target="_blank" rel="noopener">nginx 第三方模块网站</a></p><p>编译安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --add-module=/home/zhouxh/software/ngx_http_consistent_hash --add-module=/home/zhouxh/software/nginx-upstream-fair --add-module=/home/zhouxh/software/nginx-sticky-module-ng</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p><p>配置也是一样的，需要改变一下策略名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    sticky;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于整个模块是通过 cookie 实现，如果浏览器不支持 cookie，那么 sticky 不生效。</p><p>到这里 nginx 负载均衡一些扩展的第三方策略也全部介绍完了 ，有点要提醒的是以上都是基于 HTTP 七层负载均衡，还有一个是 TCP 四层负载均衡，接下来会有介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前已经将 nginx 负载均衡中的内置策略介绍完了，下面我们来看一下第三方的扩展策略，所谓的内置策略其实就是 nginx 安装后就已经自带了，对于第三方的一些策略则是需要我们在安装时要额外添加第三方的模块才能实现。下面就一一进行介绍：&lt;/p&gt;
&lt;h2 id=&quot;url-ha
      
    
    </summary>
    
      <category term="nginx" scheme="http://gittab.net/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx 负载均衡策略之内置策略</title>
    <link href="http://gittab.net/nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5%E4%B9%8B%E5%86%85%E7%BD%AE%E7%AD%96%E7%95%A5/"/>
    <id>http://gittab.net/nginx-负载均衡策略之内置策略/</id>
    <published>2018-06-22T15:26:45.000Z</published>
    <updated>2018-07-23T13:43:03.477Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 服务器在开发中我们用的比较多的有 nginx 的负载均衡，nginx 负载均衡主要是利用反向代理来实现，也就是表面上我们访问的是这个服务，其实访问的是该服务背后支撑的众多服务器中的其中一台。比如说全世界同一时间有这么多人同时在访问百度这个网站，它是怎么能够承受的住这么大的访问量呢，这时我们就应该知道其实百度这个网站的背后有很多的服务器在支撑着众多的用户的访问。但是这里就引出一个问题，用户访问的这个服务是如何分发给它背后的众多的服务器呢，于是就出现了满足各种需求的负载均衡策略，其中有 nginx 自己内置的负载均衡策略，也有第三方提供的一些负载均衡策略。今天主要谈一下 nginx 内置的负载均衡策略，主要有四种：轮询（默认）、加权轮询、最少连接 least_conn、IP 哈希 ip_hash，下面将一一进行介绍。</p><p>首先我们先安装好 nginx 服务器，下面是在 Ubuntu 16.04 系统测试的，采用的 nginx 版本是 nginx/1.12.0。</p><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p>下载基于 Linux 系统的 nginx/1.12.0 版的 nginx 服务器进行解压编译安装，下面是安装命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://nginx.org/download/nginx-1.12.0.tar.gz</span><br><span class="line">sudo tar xzf nginx-1.12.0.tar.gz</span><br><span class="line">cd nginx-1.12.0</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>上面安装成功后，nginx 默认安装在目录 /usr/local/nginx/ 下面，当然你也可以自定义安装目录，不过一般不建议这么做，以防以后都不知道到哪里去找配置文件，默认就好，安装成功后可以在 /usr/sbin/ 目录下创建一个软链接指向 /usr/local/nginx/sbin/nginx 文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/sbin/nginx /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>这样我们就不用每次启动 nginx 服务都切换到 /usr/local/nginx/sbin/ 目录下去执行 nginx 的启动命令，配置好了这些后就可以启动 nginx 服务器进行测试了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>执行上面的启动命令后在浏览器中输入 localhost 后回车出现对应的 nginx 服务器的欢迎页面就表示 nginx 服务器安装成功了，这里我们为了更好的测试首先将 nginx.conf 配置文件中 http 的默认端口 80 改成 10080，改了之后重新启动 nginx 服务器后接着在浏览器中输入 localhost:10080 后回车应该又会出现刚才的欢迎页面了。接下来就开始我们的 nginx 的负载均衡策略之旅吧。</p><h2 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h2><p>轮询这个策略是 nginx 进行负载均衡时默认采用的策略，也就是最基本的负载均衡配置，打开 /usr/local/nginx/conf/ 目录下的 nginx.conf 配置文件，我们配置一个最简单的负载均衡方式，在配置文件中 http 模块里面也就是和 http 模块里面的 server 模块同级加上以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 http 模块里面的 server 模块下面的 location 模块加上一行配置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">    proxy_pass http://loadserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分配置文件截图如下：</p><p><img src="nginx-负载均衡策略之内置策略/polling.png" alt="轮询策略配置"></p><p>这样也就配置好了最基本的负载均衡，默认采用轮询的策略将请求分发给后台服务器，当我们访问 localhost:10080 这个地址时页面轮流的展示 192.168.1.110 和 192.168.1.111 这两台主机的 nginx 服务器的欢迎页面，这里为了区分这两个欢迎页面需要修改一下这两台主机的 nginx 服务器的欢迎页面信息，欢迎页面默认存放在 /usr/local/nginx/html/ 目录下的 index.html 页面。我们只要稍微修改一下这两台主机的 nginx 欢迎页面使得每次访问的页面都是不同的，便于我们区分访问的是哪台主机的 nginx 服务器。</p><h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><p>加权轮询则是在第一种轮询的基础上对后台的每台服务赋予权重，服务器的权重比例越大，被分发到的概率也就越大，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    server 192.168.1.110:10080 weight=3;</span><br><span class="line">    server 192.168.1.111:10080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面只是给每个后台服务加上了一个权重比例，拿上面的配置举例：用户将会每访问三次 192.168.1.110 这个服务访问一次 192.168.1.111 这个服务。这种适合后台的各个服务的性能不一样，这时我们就可以将性能好的服务器权重设置大一些，减轻一些性能不怎么样的服务器的压力。</p><h2 id="最少连接-least-conn"><a href="#最少连接-least-conn" class="headerlink" title="最少连接 least_conn"></a>最少连接 least_conn</h2><p>最少连接是每次请求都将请求分发给后台服务连接数最少的那台服务上，当然如果每台服务还配置了权重，那么这时会取连接数和权重比值最小的那台服务，如果连接数和权重的比值都相同的话就会采取轮询的方式进行分发，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置只是加了一个调度策略 least_conn，其他和轮询的方式一样，当然你也可以给每台服务加上权重比例，分发时就会选择 conn / weight 值最小的那台服务，这种方式适合请求处理时间长短不一造成服务器过载的情况。</p><h2 id="IP-哈希-ip-hash"><a href="#IP-哈希-ip-hash" class="headerlink" title="IP 哈希 ip_hash"></a>IP 哈希 ip_hash</h2><p>ip_hash 这种负载策略是根据客户端的 IP 地址的 hash 结果来进行分发，这样的话能够确保每个访客访问后端固定的一台服务器，这种情况对于需要保存用户的 session 信息的应用就很方便了，它避免了同一个用户访问到不同的服务器上产生 session 共享的问题。配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.1.110:10080;</span><br><span class="line">    server 192.168.1.111:10080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置只是加了一个调度策略 ip_hash，其他也和轮询的方式一样，这里你也可以给每台服务加上权重比例，分发时在该客户端 IP 第一次访问时就会优先选择 weight 值最大的那台服务。</p><h2 id="其他配置说明"><a href="#其他配置说明" class="headerlink" title="其他配置说明"></a>其他配置说明</h2><p>其实每个后台服务器的配置除了权重 weight 还有一些配置，比如说下面的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream loadserver &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.1.110:10080 weight=5 ;</span><br><span class="line">    server 192.168.1.111:10080 weight=1;</span><br><span class="line">    server 192.168.1.112:10080 weight=1 max_fails=3 fail_timeout=30s;</span><br><span class="line">    server 192.168.1.113:10080 down;</span><br><span class="line">    server 192.168.1.114:10080 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置说明：<br>1.weight 的值默认为1，weight 越大，服务器负载的权重就越大，访问的概率越高。<br>2.down 表示当前服务器暂时不参与负载。<br>3.backup 表示其它所有的非 backup 服务器 down 或者忙的时候才会请求 backup 服务器，所以这台服务器压力最轻，一般这台服务器当做是备用服务器。<br>3.max_fails 表示允许请求失败的次数，默认为 1，当超过最大次数时，返回proxy_next_upstream 模块定义错误。<br>4.fail_timeout 表示每次失败后暂停的时间。</p><p>到这里就全部介绍完了 nginx 负载均衡内置的一些策略，还有第三方扩展的一些策略，未完待续………</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 服务器在开发中我们用的比较多的有 nginx 的负载均衡，nginx 负载均衡主要是利用反向代理来实现，也就是表面上我们访问的是这个服务，其实访问的是该服务背后支撑的众多服务器中的其中一台。比如说全世界同一时间有这么多人同时在访问百度这个网站，它是怎么能够承受的
      
    
    </summary>
    
      <category term="nginx" scheme="http://gittab.net/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx 的正向代理和反向代理</title>
    <link href="http://gittab.net/nginx-%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://gittab.net/nginx-的正向代理和反向代理/</id>
    <published>2018-06-20T16:38:39.000Z</published>
    <updated>2018-07-23T13:43:03.713Z</updated>
    
    <content type="html"><![CDATA[<p>nginx 服务器在我们平常的软件开发中可能还是用到的比较多的，那么有一个问题我们就应该明白，也许让你去实现轻而易举，但说到其中的原理就有点不是很清楚了。下面就谈谈我自己对正向代理和反向代理的理解：首先有一个用户 C，三台服务器 S1，S2 和 S3，S1，S2，S3 在同一局域网内互相可访问，但 S1 对外网开放，S2 和 S3 不对外网开放，还有一份数据资源 D，资源 D 放在服务器 S2 和 S3 上。</p><h2 id="nginx-正向代理"><a href="#nginx-正向代理" class="headerlink" title="nginx 正向代理"></a>nginx 正向代理</h2><p>这时用户 C 明确知道自己想访问的数据资源 D 在服务器 S2 上，用户 C 想要访问这份资源但是没办法直接访问服务器 S2，用户 C 想到服务器 S1 和 S2 在同一局域网并且互相可访问，而自己能够访问服务器 S1，所以用户 C 就通过服务器 S1 去访问服务器 S2 上的资源 D。那么正向代理就是对于用户 C 来说他是明确知道他要访问的数据资源 D 在哪个服务器上；对于服务器 S1 来说他只充当了用户 C 的中间代理角色；而对于服务器 S2 来说他只知道访问他的资源的是服务器 S1，根本不知道用户 C 的存在。</p><p>正向代理的整个流程就是用户 C 访问服务器 S2 上的数据资源 D，但是是通过借助服务器 S1 来进行访问，服务器 S1 得到数据资源后再返回给用户 C。</p><h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>还是刚开始上面说的这些：用户 C，服务器 S1，S2 和 S3，以及服务器 S2 和 S3 上的数据资源 D。这时用户 C 并不知道数据资源 D 在服务器 S2 和 S3 上面，他只知道访问服务器 S1 可以得到自己想要的内容，于是他每次都是直接访问服务器 S1，只不过提供给用户 C 数据资源的都是服务器 S2 或者 S3。那么反向代理就是对于用户 C 来说他是不知道数据资源 D 具体在哪里，是由谁提供的；对于服务器 S1 来说每次都接收用户的请求，然后再把请求交给真正能提供资源的服务器 S2 或 S3；对于服务器 S2 和 S3 来说同样也都不知道访问这份资源的真实用户是谁，只是和服务器 S1 进行交互。</p><p>反向代理的整个流程就是用户 C 访问服务器 S1 获取数据资源 D，服务器 S1 将请求转交给服务器 S2 或 S3，然后得到相应的资源后再返回给用户 C。</p><p>总之，正向代理就是客户端知道服务器端，带过代理连接服务器端。反向代理就是客户端不知道服务器端，通过代理连接服务器端，具体是由哪个服务器端提供服务取决于代理的调度方式，即 nginx 中的负载均衡策略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx 服务器在我们平常的软件开发中可能还是用到的比较多的，那么有一个问题我们就应该明白，也许让你去实现轻而易举，但说到其中的原理就有点不是很清楚了。下面就谈谈我自己对正向代理和反向代理的理解：首先有一个用户 C，三台服务器 S1，S2 和 S3，S1，S2，S3 在同
      
    
    </summary>
    
      <category term="nginx" scheme="http://gittab.net/categories/nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 8 特性--Stream 流</title>
    <link href="http://gittab.net/Java-8-%E7%89%B9%E6%80%A7-Stream-%E6%B5%81/"/>
    <id>http://gittab.net/Java-8-特性-Stream-流/</id>
    <published>2018-06-12T17:06:02.000Z</published>
    <updated>2018-07-23T13:43:03.561Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 API 添加了一个新的抽象称为流 Stream，可以让你以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API 可以极大提高 Java 程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation) 得到前面处理的结果。</p><h2 id="Stream-的定义"><a href="#Stream-的定义" class="headerlink" title="Stream 的定义"></a>Stream 的定义</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作，元素是特定类型的对象，形成一个队列。 Java 中的 Stream 并不会存储元素，而是按需计算。</p><ul><li>数据源：流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li><li>聚合操作：类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的 Collection 操作不同， Stream 操作还有两个基础的特征：</p><ul><li>Pipelining: 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行 (laziness) 和短路 (short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式 (Visitor) 实现。</li></ul><p>在 Java 8 中，集合接口有两个方法生成流：</p><ul><li>stream() − 为集合创建串行流。</li><li>parallelStream() − 为集合创建并行流。</li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line"></span><br><span class="line">// 统计空字符串数量</span><br><span class="line">long count = strings.stream().filter(String::isEmpty).count();</span><br><span class="line">System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">// 流并行处理</span><br><span class="line">count = strings.parallelStream().filter(String::isEmpty).count();</span><br><span class="line"></span><br><span class="line">// 将字符串不为空的筛选出来并且以逗号分隔合并起来</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure><h2 id="map-映射"><a href="#map-映射" class="headerlink" title="map 映射"></a>map 映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">// 求各元素的平方</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">System.out.println(&quot;Squares List: &quot; + squaresList);</span><br></pre></td></tr></table></figure><h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);</span><br><span class="line">IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 根据景区等级分组</span><br><span class="line">List&lt;Scenic&gt; scenicList = new ArrayList&lt;&gt;();</span><br><span class="line">scenicList.add(new Scenic(1L, &quot;西湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(2L, &quot;千岛湖&quot;, 5));</span><br><span class="line">scenicList.add(new Scenic(3L, &quot;乌镇&quot;, 4));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;雷峰塔&quot;, 3));</span><br><span class="line">scenicList.add(new Scenic(4L, &quot;灵隐寺&quot;, 4));</span><br><span class="line">Map&lt;Integer, List&lt;Scenic&gt;&gt; mapGroup = scenicList.stream().collect(Collectors.groupingBy(Scenic::getScenicLevel));</span><br><span class="line">System.out.println(mapGroup);</span><br></pre></td></tr></table></figure><h2 id="转成-Map"><a href="#转成-Map" class="headerlink" title="转成 Map"></a>转成 Map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* toMap 如果集合对象有重复的key，会报错Duplicate key ....</span><br><span class="line">*/</span><br><span class="line">//Map&lt;Long, Scenic&gt; scenicMap = scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a));</span><br><span class="line">//System.out.println(scenicMap);</span><br><span class="line"></span><br><span class="line">// 可以用 (k1,k2)-&gt;k1 来设置，如果有重复的 key,则保留 key1,舍弃 key2</span><br><span class="line">Map&lt;Long, Scenic&gt; scenicMap = scenicList.stream().collect(Collectors.toMap(Scenic::getId, a -&gt; a, (k1, k2) -&gt; k1));</span><br><span class="line">System.out.println(scenicMap);</span><br></pre></td></tr></table></figure><h2 id="reduce-sum-求和"><a href="#reduce-sum-求和" class="headerlink" title="reduce sum 求和"></a>reduce sum 求和</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">// 没有起始值时返回为Optional类型</span><br><span class="line">Optional&lt;Integer&gt; sumOptional = integers.stream().reduce(Integer::sum);</span><br><span class="line">System.out.println(sumOptional.get());</span><br><span class="line"></span><br><span class="line">// 可以给一个起始种子值</span><br><span class="line">Integer sumReduce = integers.stream().reduce(0, Integer::sum);</span><br><span class="line">System.out.println(sumReduce);</span><br><span class="line"></span><br><span class="line">//直接用sum方法</span><br><span class="line">Integer sum = integers.stream().mapToInt(i -&gt; i).sum();</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><h2 id="根据某个属性求平均数"><a href="#根据某个属性求平均数" class="headerlink" title="根据某个属性求平均数"></a>根据某个属性求平均数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 等级平均数</span><br><span class="line">OptionalDouble average = scenicList.stream().mapToInt(Scenic :: getScenicLevel).average();</span><br><span class="line">System.out.println(average.getAsDouble());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8 API 添加了一个新的抽象称为流 Stream，可以让你以一种声明的方式处理数据，Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API 可以极大提高 Java 程序员的生产力
      
    
    </summary>
    
      <category term="Java 8" scheme="http://gittab.net/categories/Java-8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 8 特性--Optional 类、时间 API 以及 Base64 编解码</title>
    <link href="http://gittab.net/Java-8-%E7%89%B9%E6%80%A7-Optional-%E7%B1%BB%E3%80%81%E6%97%B6%E9%97%B4-API-%E4%BB%A5%E5%8F%8A-Base64-%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>http://gittab.net/Java-8-特性-Optional-类、时间-API-以及-Base64-编解码/</id>
    <published>2018-06-12T15:07:35.000Z</published>
    <updated>2018-07-23T13:43:02.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p>Optional 类是一个可以为 null 的容器对象，可以保存类型 T 的值，或者仅仅保存 null，它提供很多有用的方法，让我们不用再显式的进行空值检测，Optional 类的引入很好的避免了发生空指针异常，下面我们看一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer value1 = null;</span><br><span class="line">Integer value2 = 10;</span><br><span class="line"></span><br><span class="line">// Optional.ofNullable - 允许传递为 null 参数</span><br><span class="line">Optional&lt;Integer&gt; optional1 = Optional.ofNullable(value1);</span><br><span class="line"></span><br><span class="line">// Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">Optional&lt;Integer&gt; optional2 = Optional.of(value2);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;第一个参数值是否存在: &quot; + optional1.isPresent());</span><br><span class="line">System.out.println(&quot;第二个参数值是否存在: &quot; + optional2.isPresent());</span><br><span class="line"></span><br><span class="line">// Optional.orElse - 如果值存在，返回它，否则返回默认值</span><br><span class="line">Integer result1 = optional1.orElse(0);</span><br><span class="line">System.out.println(result1);</span><br><span class="line"></span><br><span class="line">//Optional.get - 获取值，值需要存在</span><br><span class="line">Integer result2 = optional2.orElse(0);</span><br><span class="line">System.out.println(result2);</span><br></pre></td></tr></table></figure></p><h2 id="Java-8-日期时间-API"><a href="#Java-8-日期时间-API" class="headerlink" title="Java 8 日期时间 API"></a>Java 8 日期时间 API</h2><p>在 Java 8 以前，我们都知道 Java 中的时间处理很繁琐，有时候还会去纠结我到底是用 java.util 包下的日期还是 java.sql 包下的日期呢。因此往往在遇到时间处理问题时都会借助于框架来实现，比如 Joda-Time。但在 Java 8 中也增加了同样的类似框架功能的时间处理 API，下面列出一些简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Clock 类使用时区来返回当前的毫秒数和日期。Clock 可以替代System.currentTimeMillis() 和 TimeZone.getDefault()。</span><br><span class="line"> </span><br><span class="line">Clock clock = Clock.systemUTC();</span><br><span class="line">System.out.println(clock.millis());</span><br><span class="line">System.out.println(System.currentTimeMillis());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前日期</span><br><span class="line">LocalDate currentDate = LocalDate.now();</span><br><span class="line">System.out.println(&quot;当前日期: &quot; + currentDate);</span><br><span class="line">// 获取当前时间</span><br><span class="line">LocalTime currentTime = LocalTime.now();</span><br><span class="line">System.out.println(&quot;当前时间: &quot; + currentTime);</span><br><span class="line">// 获取当前日期时间</span><br><span class="line">LocalDateTime currentDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(&quot;当前日期时间: &quot; + currentDateTime);</span><br><span class="line">// 根据当前日期时间获取当前日期</span><br><span class="line">LocalDate currentDate1 = currentDateTime.toLocalDate();</span><br><span class="line">System.out.println(&quot;currentDate1: &quot; + currentDate1);</span><br><span class="line">// 根据当前日期时间获取当前时间</span><br><span class="line">LocalTime currentTime1 = currentDateTime.toLocalTime();</span><br><span class="line">System.out.println(&quot;currentTime1: &quot; + currentTime1);</span><br><span class="line"></span><br><span class="line">Month month = currentDateTime.getMonth();</span><br><span class="line">int day = currentDateTime.getDayOfMonth();</span><br><span class="line">int seconds = currentDateTime.getSecond();</span><br><span class="line">System.out.println(&quot;月: &quot; + month +&quot;, 日: &quot; + day +&quot;, 秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">// 指定日期</span><br><span class="line">LocalDateTime date2 = currentDateTime.withDayOfMonth(10).withYear(2012);</span><br><span class="line">System.out.println(&quot;date2: &quot; + date2);</span><br><span class="line"></span><br><span class="line">// 12 december 2014</span><br><span class="line">LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);</span><br><span class="line">System.out.println(&quot;date3: &quot; + date3);</span><br><span class="line"></span><br><span class="line">// 22 小时 15 分钟</span><br><span class="line">LocalTime date4 = LocalTime.of(22, 15);</span><br><span class="line">System.out.println(&quot;date4: &quot; + date4);</span><br><span class="line"></span><br><span class="line">// 解析字符串</span><br><span class="line">LocalTime date5 = LocalTime.parse(&quot;20:15:30&quot;);</span><br><span class="line">System.out.println(&quot;date5: &quot; + date5);</span><br><span class="line">// 获取当前日期时间的另一个时区的日期时间</span><br><span class="line"></span><br><span class="line">System.out.println(currentDateTime.atZone(ZoneId.of(&quot;America/New_York&quot;)));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of( 2017, Month.MAY, 16, 0, 0, 0 );</span><br><span class="line">LocalDateTime to = LocalDateTime.of( 2018, Month.MAY, 16, 23, 59, 59 );</span><br><span class="line">Duration duration = Duration.between( from, to );</span><br><span class="line">System.out.println( &quot;Duration in days: &quot; + duration.toDays() );</span><br><span class="line">System.out.println( &quot;Duration in hours: &quot; + duration.toHours());</span><br></pre></td></tr></table></figure><p>上面只是列举了一些简单的东西，其实还有一些，比如时间的加减运算，这些在用到时可以根据提示来进行我们想要的操作。</p><h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>Java 8 内置了 Base64 编码的编码器和解码器，并且 Base64 工具类提供了一套静态方法获取下面三种 BASE64 编解码器：</p><ul><li>基本：输出被映射到一组字符 A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持 A-Za-z0-9+/。</li><li>URL：输出映射到一组字符A-Za-z0-9+_，输出是 URL 和文件。</li><li>MIME：输出映射到 MIME 友好格式，输出每行不超过 76 字符，并且使用 ‘\r’ 并跟随 ‘\n’ 作为分割，编码输出最后没有行分割。</li></ul><p>下面也是一个简单的例子展示了如何获取这三种编解码器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 基本编码</span><br><span class="line">String base64encodedString = Base64.getEncoder().encodeToString(&quot;java 8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (基本) :&quot; + base64encodedString);</span><br><span class="line">// 基本解码</span><br><span class="line">byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">// URL 编码</span><br><span class="line">base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;url?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">// URL 解码</span><br><span class="line">byte[] base64decodedBytesUrl = Base64.getUrlDecoder().decode(base64encodedString);</span><br><span class="line">System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytesUrl, &quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">    stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">// MINE 编码</span><br><span class="line">String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Optional-类&quot;&gt;&lt;a href=&quot;#Optional-类&quot; class=&quot;headerlink&quot; title=&quot;Optional 类&quot;&gt;&lt;/a&gt;Optional 类&lt;/h2&gt;&lt;p&gt;Optional 类是一个可以为 null 的容器对象，可以保存类型 T 的
      
    
    </summary>
    
      <category term="Java 8" scheme="http://gittab.net/categories/Java-8/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 8 特性--Lambda 表达式、接口默认方法以及方法引用</title>
    <link href="http://gittab.net/Java-8-%E7%89%B9%E6%80%A7-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    <id>http://gittab.net/Java-8-特性-Lambda-表达式、接口默认方法以及方法引用/</id>
    <published>2018-05-30T16:37:41.000Z</published>
    <updated>2018-07-23T13:43:03.641Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本，Java 8 增加了许多的新特性，在此先记录一下 Lambda 表达式，接口默认方法和方法引用这三个特性。</p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Lambda 表达式，也可称为闭包，允许把函数作为一个方法的参数（函数作为参数传递进方法中），使用 Lambda 表达式可以使代码变的更加简洁紧凑。<br>语法格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression  或  (parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure></p><p>主要特征：</p><ul><li>可选类型声明，不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号，一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号，如果主体只包含一个语句，就不需要使用大括号。</li><li>可选的返回关键字，如果主体只有一个表达式返回值则编译器会自动返回值，大括号的话需要指明表达式返回了一个数值。</li></ul><p>下面通过一些小例子来展示，首先先定义两个函数式接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface MathOperation &#123;</span><br><span class="line">    int operate(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Greeting &#123;</span><br><span class="line">    void sayMessage(String greeting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类，通过 main 方法来进行测试，代码中有详细注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Java8 java8 = new Java8();</span><br><span class="line">    //参数类型可声明可不声明</span><br><span class="line">    MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">    MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">    </span><br><span class="line">    //可选的参数圆括号</span><br><span class="line">    Greeting greeting = message -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    Greeting greeting1 = (message) -&gt; System.out.println(&quot;hello &quot; + message);</span><br><span class="line">    greeting.sayMessage(&quot;Tom&quot;);</span><br><span class="line">    greeting1.sayMessage(&quot;Jim&quot;);</span><br><span class="line">    </span><br><span class="line">    //可选的大括号以及可选的返回关键字，当有大括号时返回值需指定 return 语句</span><br><span class="line">    MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">        return a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">    MathOperation division = (a, b) -&gt; a / b;</span><br><span class="line">    //测试执行输出，将上面定义的函数传进 operate 方法中</span><br><span class="line">    System.out.println(java8.operate(1, 2, addition));</span><br><span class="line">    //上面的另一种写法</span><br><span class="line">    System.out.println(addition.operate(1, 2));</span><br><span class="line">    </span><br><span class="line">    System.out.println(java8.operate(1, 2, subtraction));</span><br><span class="line">    System.out.println(java8.operate(1, 2, multiplication));</span><br><span class="line">    System.out.println(java8.operate(1, 2, division));</span><br><span class="line">    System.out.println(java8.operate(1,2, (a, b) -&gt; a + b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">    return mathOperation.operate(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h2><p>默认方法就是接口可以有实现方法，而且不需要实现类去实现这个默认方法，定义时我们只需在方法名前面加个 default 关键字即可实现默认方法。</p><p>至于为什么会产生这个特性？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是当需要修改接口时候，需要修改它的全部实现类，目前 java 8之前的集合框架没有 foreach 方法，通常能想到的解决办法是在 JDK 里给相关的接口添加新的方法定义及给相应实现类添加实现，然而对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现，所以才引进的默认方法。目的就是为了解决接口的修改与现有的实现不兼容的问题。</p><p>下面是接口默认方法和接口静态默认方法的基本实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Action1 &#123;</span><br><span class="line">    //默认方法</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //静态默认方法</span><br><span class="line">    static void fun() &#123;</span><br><span class="line">        System.out.println(&quot;玩&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Action2 &#123;</span><br><span class="line">    default void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃东西2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里接口 Action1 和 Action2 都有 eat 这个相同的默认方法，当一个实现类同时实现了这个两个接口时就需要实现类显式的覆盖两个接口中相同的 eat 方法，至于实现类中如何重写 eat 方法取决于实现类，实现类既可以完完全全由自己重写，也可以使用 super 来调用两个接口中的 eat 方法。上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Cat implements Action1, Action2 &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">    &#125;*/</span><br><span class="line">    </span><br><span class="line">    /*@Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        Action1.super.eat();</span><br><span class="line">        Action2.super.eat();</span><br><span class="line">        Action1.fun();</span><br><span class="line">    &#125;*/</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用通过方法的名字来指向一个方法，方法引用可以使语言的构造更紧凑简洁，减少冗余代码，方法引用使用一对冒号 :: 表示。当要传递给Lambda体内的操作已经有实现的方法了，就可以使用方法引用了。</p><p>先定义一个函数式接口和一个测试类以及类中的一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Say&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t1, T t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">    private String name = &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">    public Student() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Student create(Supplier&lt;Student&gt; studentSupplier) &#123;</span><br><span class="line">        return studentSupplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String study() &#123;</span><br><span class="line">        System.out.println(&quot;study&quot;);</span><br><span class="line">        return &quot;knowledge&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String fun() &#123;</span><br><span class="line">        System.out.println( &quot;fun&quot;);</span><br><span class="line">        return &quot;fun&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ask() &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; ask&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void say(Student student) &#123;</span><br><span class="line">        System.out.println(this.getName() + &quot; say to&quot; + student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    //set get 方法已省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 main 方法测试方法引用的具体使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</span><br><span class="line">    Student student = Student.create(Student :: new );</span><br><span class="line">    Student student1 = Student.create(() -&gt; new Student(&quot;小红&quot;));</span><br><span class="line">    Student student2 = Student.create(() -&gt; new Student(&quot;小绿&quot;));</span><br><span class="line">    </span><br><span class="line">    //静态方法引用：它的语法是Class::static_method</span><br><span class="line">    Supplier&lt;String&gt; supplier1 = Student :: study;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line"></span><br><span class="line">    //特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Consumer&lt;Student&gt; consumer = Student :: ask;</span><br><span class="line">    //下面 student 参数是 ask 方法的调用者</span><br><span class="line">    consumer.accept(student);</span><br><span class="line">    </span><br><span class="line">    //特定类的任意对象的方法引用：它的语法是Class::method</span><br><span class="line">    Say&lt;Student&gt; say = Student :: say;</span><br><span class="line">    //下面 student1 参数是 say 方法的调用者，student2 参数是 say 方法的参数</span><br><span class="line">    say.accept(student1, student2);</span><br><span class="line"></span><br><span class="line">    //特定对象的方法引用：它的语法是instance::method</span><br><span class="line">    supplier1 = student :: fun;</span><br><span class="line">    System.out.println(supplier1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意上面静态方法引用和特定类的任意对象的方法引用的区别，前者是一个静态方法，可通过类访问，后者则是参数列表的第一个参数是实例方法的调用者，第二个参数(或无参)是实例方法的参数时才会采取这种语法。</p><p>在使用方法引用时一定注意：</p><ol><li>方法引用所引用的方法的参数列表必须要和函数式接口中抽象方法的参数列表完全一致。</li><li>方法引用所引用的方法的的返回值必须要和函数式接口中抽象方法的返回值完全一致</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本，Java 8 增加了许多的新特性，在此先记录一下 Lambda 表达式，接口默认方法和方法引用这三个特性。&lt;/p&gt;
&lt;h2 id=&quot;Lambda-表达式&quot;&gt;&lt;a href=&quot;#Lambda-表达
      
    
    </summary>
    
      <category term="Java 8" scheme="http://gittab.net/categories/Java-8/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系统下 AES 解密报错问题</title>
    <link href="http://gittab.net/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B-AES-%E8%A7%A3%E5%AF%86%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://gittab.net/Linux-系统下-AES-解密报错问题/</id>
    <published>2018-05-28T15:03:31.000Z</published>
    <updated>2018-07-23T13:43:02.513Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在开发中遇到一个问题，就是一个服务部署在 Window 系统上的，而另一个服务部署在 Linux 系统上，Linux 系统上的服务需要通过 WebService 向 Window 系统上的服务获取数据，而这个数据是经过 AES 加密的，获取到密文之后需要进行解密，然后拿到解密之后的数据进行处理，但是在 Linux 系统服务上进行解密时却报错了，下面就是报错信息。</p><p><img src="Linux-系统下-AES-解密报错问题/AES-Error.png" alt="解密时报错信息"></p><p>遇到错误第一时间找度娘 ( 其实应该找 Google )，结果发现原来是操作系统的原因，Linux 系统下在进行 AES 加解密时生成 key 时是有问题的，key 值的生成方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator generator = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">//password 为加解密使用的密钥</span><br><span class="line">generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">Key key = generator.generateKey();</span><br></pre></td></tr></table></figure></p><p>SecureRandom 的实现尝试完全随机化生成器本身的内部状态，因此随操作系统本身的內部状态而定，该实现在 windows 上每次生成的 key 都相同，但是在 linux 系统上则不同，除非调用方在调用 getInstance 方法之后又调用了 setSeed 方法，将上述生成 key 值的方式改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KeyGenerator generator = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">//generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">//password 为加解密使用的密钥</span><br><span class="line">secureRandom.setSeed(password.getBytes());</span><br><span class="line">generator.init(128, secureRandom);</span><br><span class="line">Key key = generator.generateKey();</span><br></pre></td></tr></table></figure></p><p>上面只是修改了 key 值的生成方式，这样就能够避免在 Linux 系统上加解密失败的错误了。完整的 AES 加解密工具类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package com.ecjtu.common.util;</span><br><span class="line"></span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.KeyGenerator;</span><br><span class="line">import java.security.Key;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> */</span><br><span class="line">public class AesEncodeUtil &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String content = &quot;www.baidu.com&quot;;</span><br><span class="line">        String pwd = &quot;ecjtu&quot;;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;加密前content：&quot; + content);</span><br><span class="line">        // 加密</span><br><span class="line">        String enContent = encodeByAes(content, pwd);</span><br><span class="line">        System.out.println(&quot;加密后content：&quot; + enContent);</span><br><span class="line"></span><br><span class="line">        // 解密</span><br><span class="line">        String deContent = decodeByAes(enContent, pwd);</span><br><span class="line">        System.out.println(&quot;解密后content：&quot; + deContent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待加密内容</span><br><span class="line">     * @param password 加密密钥</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String encodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key = generateKey(password);</span><br><span class="line">        BASE64Encoder base64en = new BASE64Encoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 创建密码器</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            byte[] byteContent = content.getBytes(&quot;utf-8&quot;);</span><br><span class="line">            // 初始化</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, key);</span><br><span class="line">            // 加密</span><br><span class="line">            content = base64en.encode(cipher.doFinal(byteContent));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密</span><br><span class="line">     *</span><br><span class="line">     * @param content  待解密内容</span><br><span class="line">     * @param password 解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String decodeByAes(String content, String password) &#123;</span><br><span class="line">        Key key = generateKey(password);</span><br><span class="line">        BASE64Decoder base64de = new BASE64Decoder();</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] byteContent = base64de.decodeBuffer(content);</span><br><span class="line">            // 创建密码器</span><br><span class="line">            Cipher cipher = Cipher.getInstance(&quot;AES&quot;);</span><br><span class="line">            // 初始化</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, key);</span><br><span class="line">            // 解密</span><br><span class="line">            content = new String(cipher.doFinal(byteContent), &quot;UTF8&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据密钥生成加解密使用的 key 值</span><br><span class="line">     *</span><br><span class="line">     * @param password 加解密密钥</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Key generateKey(String password) &#123;</span><br><span class="line">        Key key = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            KeyGenerator generator = KeyGenerator.getInstance(&quot;AES&quot;);</span><br><span class="line">            //下面这种方式在 Linux 系统下会报错</span><br><span class="line">            //generator.init(128, new SecureRandom(password.getBytes()));</span><br><span class="line">            SecureRandom secureRandom = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">            secureRandom.setSeed(password.getBytes());</span><br><span class="line">            generator.init(128, secureRandom);</span><br><span class="line">            key = generator.generateKey();</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天在开发中遇到一个问题，就是一个服务部署在 Window 系统上的，而另一个服务部署在 Linux 系统上，Linux 系统上的服务需要通过 WebService 向 Window 系统上的服务获取数据，而这个数据是经过 AES 加密的，获取到密文之后需要进行解密，然后
      
    
    </summary>
    
      <category term="Java" scheme="http://gittab.net/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective Java - 创建和销毁对象</title>
    <link href="http://gittab.net/Effective-Java-%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://gittab.net/Effective-Java-创建和销毁对象/</id>
    <published>2018-05-23T15:04:37.000Z</published>
    <updated>2018-07-23T13:43:02.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到多个构造器参数时要考虑用构建器"><a href="#遇到多个构造器参数时要考虑用构建器" class="headerlink" title="遇到多个构造器参数时要考虑用构建器"></a>遇到多个构造器参数时要考虑用构建器</h2><p>当我们的类的一些属性是必须的，有些属性是可选的，参数较多的情况下我们可以适当考虑使用构建器，其实在 Java 开发中我们也经常遇到这种通过构建器来创建类实例的情况，然后再结合链式调用写出来的代码还是比较美观的。下面结合一个简单的例子来说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">/**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> */</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private String phone;</span><br><span class="line">    /**</span><br><span class="line">     * 可选参数</span><br><span class="line">     */</span><br><span class="line">    private Integer sex;</span><br><span class="line">    /**</span><br><span class="line">     * 可选参数</span><br><span class="line">     */</span><br><span class="line">    private String birthday;</span><br><span class="line">    /**</span><br><span class="line">     * 可选参数</span><br><span class="line">     */</span><br><span class="line">    private String[] hobby;</span><br><span class="line"></span><br><span class="line">    public static class Builder &#123;</span><br><span class="line">        private String username;</span><br><span class="line">        private String password;</span><br><span class="line">        private String phone;</span><br><span class="line">        /**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         */</span><br><span class="line">        private Integer sex = 1;</span><br><span class="line">        /**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         */</span><br><span class="line">        private String birthday = &quot;0-0-0-0&quot;;</span><br><span class="line">        /**</span><br><span class="line">         * 可选参数,给个默认值</span><br><span class="line">         */</span><br><span class="line">        private String[] hobby = new String[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        public Builder(String username, String password, String phone) &#123;</span><br><span class="line">            this.username = username;</span><br><span class="line">            this.password = password;</span><br><span class="line">            this.phone = phone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder sex(Integer sex) &#123;</span><br><span class="line">            sex = sex;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder birthday(String birthday) &#123;</span><br><span class="line">            birthday = birthday;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Builder hobby(String[] hobby) &#123;</span><br><span class="line">            hobby = hobby;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public User build() &#123;</span><br><span class="line">            return new User(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(Builder builder) &#123;</span><br><span class="line">        username = builder.username;</span><br><span class="line">        password = builder.password;</span><br><span class="line">        phone = builder.phone;</span><br><span class="line">        sex = builder.sex;</span><br><span class="line">        birthday = builder.birthday;</span><br><span class="line">        hobby = builder.hobby;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;username=&apos;&quot; + username + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, password=&apos;&quot; + password + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, phone=&apos;&quot; + phone + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, sex=&quot; + sex +</span><br><span class="line">                &quot;, birthday=&apos;&quot; + birthday + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, hobby=&quot; + Arrays.toString(hobby) +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>User 对象的创建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        User user = new User.Builder(&quot;admin&quot;, &quot;123456&quot;, &quot;13999999999&quot;).sex(0).build();</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，这里只是一个简单的小例子，开发中一般不会用这种方式来创建实体类，可能还是需要看个人开发时具体情况决定是否采用这种方式，这里只对这种创建方式做一个简单的介绍。</p><h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><p>一般来说，最好能重用对象而不是在每次需要时都去频繁的创建，重用的方式快，而且能够避免频繁创建浪费资源。像下面这种情况就推荐重用对象,可以对比以下两种方式的差别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 不推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> */</span><br><span class="line">public class Person1 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate = new Date();</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomStart = calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        Date boomEnd = calendar.getTime();</span><br><span class="line">        return birthDate.compareTo(boomStart) &gt;= 0 &amp;&amp; birthDate.compareTo(boomEnd) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Calendar;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.TimeZone;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 推荐这样做</span><br><span class="line"> *</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> */</span><br><span class="line">public class Person2 &#123;</span><br><span class="line"></span><br><span class="line">    private final Date birthDate = new Date();</span><br><span class="line"></span><br><span class="line">    private static final Date BOOM_START;</span><br><span class="line">    private static final Date BOOM_END;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span><br><span class="line">        calendar.set(1946, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_START = calendar.getTime();</span><br><span class="line">        calendar.set(1965, Calendar.JANUARY, 1, 0, 0, 0);</span><br><span class="line">        BOOM_END = calendar.getTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBabyBoomer() &#123;</span><br><span class="line">        return birthDate.compareTo(BOOM_START) &gt;= 0 &amp;&amp; birthDate.compareTo(BOOM_END) &lt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><p>我们在日常开发中可能稍有不慎就会遇到内存泄漏的问题，这需要我们从细节去防止这种情况的发生，一般而言，只要类是自己管理内存，就应该警惕内存泄漏的问题。下面展示一种可能会发生内存泄漏的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.ecjtu;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.EmptyStackException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author zhouxh</span><br><span class="line"> */</span><br><span class="line">public class Stack &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] elements;</span><br><span class="line">    private int size = 0;</span><br><span class="line">    private static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br><span class="line"></span><br><span class="line">    public Stack() &#123;</span><br><span class="line">        elements = new Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(Object object) &#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop1() &#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        return elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object pop2() &#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            throw new EmptyStackException();</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = elements[--size];</span><br><span class="line">        /*</span><br><span class="line">        将弹出的值赋空，以便 jvm 回收，如果不赋空将不会被 jvm 回收，因为栈内部依然维护着这些对象的过期引用。</span><br><span class="line">        过期引用是指永远不会被解除的引用，在这里就是指在 elements 数组活动之外的引用，即元素下标小于 size 的那些元素。</span><br><span class="line">        所以一旦数组元素变成了非活动部分的一部分就应该手动清空这些数组元素。</span><br><span class="line">        */</span><br><span class="line">        elements[size] = null;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void ensureCapacity() &#123;</span><br><span class="line">        if (elements.length == size) &#123;</span><br><span class="line">            elements = Arrays.copyOf(elements, 2 * size + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个随着栈的不断的弹栈和压栈，每次弹出如果不清空该引用，随着量的增加就可能造成内存泄漏的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;遇到多个构造器参数时要考虑用构建器&quot;&gt;&lt;a href=&quot;#遇到多个构造器参数时要考虑用构建器&quot; class=&quot;headerlink&quot; title=&quot;遇到多个构造器参数时要考虑用构建器&quot;&gt;&lt;/a&gt;遇到多个构造器参数时要考虑用构建器&lt;/h2&gt;&lt;p&gt;当我们的类的一些属性
      
    
    </summary>
    
      <category term="Effective Java" scheme="http://gittab.net/categories/Effective-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系统下远程连接和远程拷贝命令</title>
    <link href="http://gittab.net/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E5%91%BD%E4%BB%A4/"/>
    <id>http://gittab.net/Linux-系统下远程连接和远程拷贝命令/</id>
    <published>2018-05-09T16:45:15.000Z</published>
    <updated>2018-07-23T13:43:02.973Z</updated>
    
    <content type="html"><![CDATA[<p>在平常开发部署中，我们可能经常需要远程连接到服务器上执行一些操作，有时还需要拷贝相应的文件过去，这里记录下平常自己用的比较多的远程连接命令以及远程拷贝文件的命令。</p><h3 id="远程连接-ssh-命令"><a href="#远程连接-ssh-命令" class="headerlink" title="远程连接 ssh 命令"></a>远程连接 ssh 命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure><p>上面是通过默认 22 端口连接，如果需要指定端口连接，加上 -p 参数指定相应端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 33109 zhouxh@192.168.0.134</span><br></pre></td></tr></table></figure></p><h3 id="远程拷贝-scp-命令"><a href="#远程拷贝-scp-命令" class="headerlink" title="远程拷贝 scp 命令"></a>远程拷贝 scp 命令</h3><p>将本地文件 file1 拷贝到另一台主机用户名为 zhouxh 的家目录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /home/zhouxh/file1 zhouxh@192.168.0.134:/home/zhouxh/</span><br></pre></td></tr></table></figure></p><p>将本地目录 dir1 拷贝到另一台主机用户名为 zhouxh 的家目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/zhouxh/dir1 zhouxh@192.168.0.134:/home/zhouxh/</span><br></pre></td></tr></table></figure><p>将另一台主机用户名为 zhouxh 的家目录下的文件 file1 拷贝到本地家目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp zhouxh@192.168.0.134:/home/zhouxh/file1 /home/zhouxh/</span><br></pre></td></tr></table></figure><p>将另一台主机用户名为 zhouxh 的家目录下的 dir1 目录拷贝到本地家目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r zhouxh@192.168.0.134:/home/zhouxh/dir1 /home/</span><br></pre></td></tr></table></figure><p>以上拷贝命令都是通过默认 22 端口拷贝，如果需要指定端口，加上 -P 参数，注意 P 大写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 33109 /home/zhouxh/file1 zhouxh@192.168.0.134:/home/zhouxh/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在平常开发部署中，我们可能经常需要远程连接到服务器上执行一些操作，有时还需要拷贝相应的文件过去，这里记录下平常自己用的比较多的远程连接命令以及远程拷贝文件的命令。&lt;/p&gt;
&lt;h3 id=&quot;远程连接-ssh-命令&quot;&gt;&lt;a href=&quot;#远程连接-ssh-命令&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://gittab.net/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 系统安装以及一些开发中必要的安装配置</title>
    <link href="http://gittab.net/Ubuntu-%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%BC%80%E5%8F%91%E4%B8%AD%E5%BF%85%E8%A6%81%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://gittab.net/Ubuntu-系统安装以及一些开发中必要的安装配置/</id>
    <published>2018-05-07T15:46:03.000Z</published>
    <updated>2018-07-23T13:43:02.465Z</updated>
    
    <content type="html"><![CDATA[<p>对于开发人员来说，个人强烈推荐使用 Linux 系统进行开发，至于为什么，这里贴出自己刚开始尝试使用 Linux 系统时看的一个博主写的文章，可以说就是因为看了这位博主的文章才立即决定装上 Linux 系统，开始了我的 Linux 系统之旅，从此停不下来了。下面就是这位博主写的文章地址，里面详细阐述了为什么要使用 Linux 系统。<br><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/" target="_blank" rel="noopener">http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/</a><br><a href="http://ghosertblog.github.io/blog/2012/10/14/ubuntu-living-handbook/" target="_blank" rel="noopener">Ubuntu桌面生存指南 (1) — 选择 Linux</a></p><p>这位博主写了 5 篇文章关于 Linux 系统的，建议从第一篇开始看，一直看下去，看完之后如果还是不想进入 Linux 系统的世界，那么可能 Linux 系统与你无缘，这里并无冒犯的意思，纯属个人喜好。</p><p>博主从零开始全面的介绍了 Linux 系统，（当然还是要有点 Linux 系统的基础去看更好）一直到 Linux 系统的安装以及后面的维护和备份，值得去好好的看一遍，那么这里我主要是想记录下自己的安装过程以及开发中的一些必要软件安装和配置，以防以后重复去搜索资源。</p><h3 id="Ubuntu-系统的安装"><a href="#Ubuntu-系统的安装" class="headerlink" title="Ubuntu 系统的安装"></a>Ubuntu 系统的安装</h3><p>U 盘启动盘制作<br>对于 Linux 系统的启动盘制作很简单，只需要下载一个制作工具即可，下载链接如下：</p><p><a href="http://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/#button" target="_blank" rel="noopener">U 盘启动盘制作软件</a></p><p><img src="Ubuntu-系统安装以及一些开发中必要的安装配置/download.png" alt="制作工具下载网页"></p><p>下载完制作工具后，准备好 Linux 系统镜像文件，以 Ubuntu 镜像为例，最好去官网下载最新的，而且带有 LTS 结尾的 ISO 文件，下载好以后打开刚才下载的制作软件</p><p><img src="Ubuntu-系统安装以及一些开发中必要的安装配置/make-usb.jpg" alt="制作工具使用"></p><p>图中三处标红的地方从上到下分别是制作的启动盘要安装的镜像类型，准备好的镜像文件位置，要制作的 U 盘。这里提醒记得备份 U 盘里面的重要资料，制作完成之后会全部格式化。选择好之后点击 create 按钮，等个十来分钟应该就会出现如下字样了。</p><p><img src="Ubuntu-系统安装以及一些开发中必要的安装配置/success.jpg" alt="制作成功"></p><p>到这里 U 盘启动盘就已经制作好了，接下来就是插入你要安装系统的笔记本或者台式机上，设置好从 U 盘启动，进入系统后出现以下界面(有的版本不一样可能不会立马进入这个界面，会直接进入安装界面，可以点击旁边的 Try Ubuntu 按钮来进入这个界面，直接安装可能会出问题)</p><p><img src="Ubuntu-系统安装以及一些开发中必要的安装配置/install.png" alt="Ubuntu 系统安装"></p><p>在从这里点击进入安装界面，接下来就是按照指示进行操作即可，实在不懂的可以百度找一下具体的安装步骤，中间分区的步骤尽量自己来进行分区，具体的分区方案以下供参考：</p><p>一般来说一个 Ubuntu 的系统在安装之初应该有三个分区，他们分别是挂载于根目录： /, home 目录： /home 的两个分区以及 swap 分区。swap 分区是指虚拟内存的交换区，一般设置为实际内存容量的两倍大小即可。<br>假如有一台 8G 内存，1T 磁盘的笔记本电脑，swap: 15G  15360M，/:  100G  102400M<br>/boot:    20G     20480M，/home:   剩余空间都分给 home</p><p><a href="https://blog.csdn.net/u012052268/article/details/77145427" target="_blank" rel="noopener">安装 Ubuntu Linux 系统时硬盘分区最合理的方法</a><br><a href="https://blog.csdn.net/zzxian/article/details/25487951" target="_blank" rel="noopener">win7 下制作 Ubuntu 系统安装启动盘和 U 盘安装 Ubuntu 全过程</a></p><h3 id="Ubuntu-系统软件源配置"><a href="#Ubuntu-系统软件源配置" class="headerlink" title="Ubuntu 系统软件源配置"></a>Ubuntu 系统软件源配置</h3><p>到这里 Ubuntu 系统应该安装完成了，接下来就可以配置日常开发中需要的工具软件了<br>软件源配置：Ctrl + Alt + T 快捷键打开终端命令行，输入 update-manager 回车打开软件更新器，这时可能会提示检查更新，可以选择稍后提醒，</p><h3 id="Ubuntu-系统软件后台启动"><a href="#Ubuntu-系统软件后台启动" class="headerlink" title="Ubuntu 系统软件后台启动"></a>Ubuntu 系统软件后台启动</h3><p>在 Ubuntu 系统的终端运行软件会将终端占据，这样你不得不重新启动一个终端来执行命令，这里有一个脚本配置软件从后台启动，不会占据终端。在 home 目录下创建 bin目录，然后在 bin 目录下新建一个文本文件，命名 x ，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">&quot;$@&quot; 1&gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>并且给这个脚本文件添加可执行权限，这个脚本的大意是运行软件的时候，不输出任何标准信息和错误信息，并且在后台运行，这样就可以避免占据终端的行为。比如启动火狐浏览器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x Firefox</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-系统-vi-编辑器配置"><a href="#Ubuntu-系统-vi-编辑器配置" class="headerlink" title="Ubuntu 系统 vi 编辑器配置"></a>Ubuntu 系统 vi 编辑器配置</h3><p>在终端中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ set -o vi</span><br></pre></td></tr></table></figure><p>可以开启以兼容 vi 的快捷键操作 bash 命令，此时你可以在终端使用 Esc 切换到命令模式，在命令模式下，按 h，l 可以左右移动光标，按 j，k 可以切换前一条后一条命令。x可以修改字符，”$， ^”可以返回命令尾部或头部，i 可以返回编辑模式。Vi/Vim 本身不需要安装，但是如果你更乐衷于视觉效果更好，功能更丰富的 GUI 版本可以安装GVim:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim-gnome</span><br></pre></td></tr></table></figure><p>执行以下命令进入 vi 编辑器训练教程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor</span><br></pre></td></tr></table></figure></p><h3 id="Ubuntu-系统终端分屏工具-Tmux"><a href="#Ubuntu-系统终端分屏工具-Tmux" class="headerlink" title="Ubuntu 系统终端分屏工具 Tmux"></a>Ubuntu 系统终端分屏工具 Tmux</h3><p> 运行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install tmux</span><br></pre></td></tr></table></figure><p>安装过程中如果遇到由于包依赖问题导致安装失败的话，可以尝试下面命令进行修复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -f install</span><br></pre></td></tr></table></figure><p>个性化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .tmux</span><br><span class="line">git clone https://github.com/gpakosz/.tmux.git</span><br><span class="line">ln -s .tmux/.tmux.conf</span><br><span class="line">cp .tmux/.tmux.conf.local .</span><br></pre></td></tr></table></figure><p>相关链接：<br><a href="https://blog.csdn.net/u014015972/article/details/51611817" target="_blank" rel="noopener">tmux 的使用</a><br><a href="http://blog.jobbole.com/87584/" target="_blank" rel="noopener">Tmux 速成教程：技巧和调整</a><br><a href="http://www.cnblogs.com/chjbbs/p/5689011.html" target="_blank" rel="noopener">tmux的使用方法和个性化配置</a></p><h3 id="Ubuntu-系统安装-Chrome-浏览器"><a href="#Ubuntu-系统安装-Chrome-浏览器" class="headerlink" title="Ubuntu 系统安装 Chrome 浏览器"></a>Ubuntu 系统安装 Chrome 浏览器</h3><p>在终端中，执行以下四条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/</span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install google-chrome-stable</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-系统安装-JDK"><a href="#Ubuntu-系统安装-JDK" class="headerlink" title="Ubuntu 系统安装 JDK"></a>Ubuntu 系统安装 JDK</h3><p>去官网下载 Ubuntu 系统的 JDK 开发工具压缩包，解压到某个文件夹中，然后配置环境变量，以下是我电脑上的一些环境变量配置，我这里是配置在 /etc/profile 文件中的，对所有用户有效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_144</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export ZOO_HOME=/home/zhouxh/software/zookeeper-3.4.11</span><br><span class="line">export M2_HOME=/opt/maven/apache-maven-3.5.0</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;M2_HOME&#125;/bin:$&#123;ZOO_HOME&#125;/bin:/usr/local/curl/bin:$PATH</span><br></pre></td></tr></table></figure><p>配置好后要想环境变量立即生效可以执行以下命令,或者重启生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键"><a href="#Ubuntu-系统安装截图工具-deepin-scrot-并且配置快捷键" class="headerlink" title="Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键"></a>Ubuntu 系统安装截图工具 deepin-scrot 并且配置快捷键</h3><p>执行以下命令下载截图工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://packages.linuxdeepin.com/deepin/pool/main/d/deepin-scrot/deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure><p>截图工具安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-xlib</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure><p>当安装失败时可能是由于依赖问题，执行下面命令进行修复之后继续安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get -f install</span><br><span class="line">sudo dpkg -i deepin-scrot_2.0-0deepin_all.deb</span><br></pre></td></tr></table></figure><p>deepin-scrot 截图快捷键设置：<br><img src="Ubuntu-系统安装以及一些开发必要的安装配置/deepin-scrot-key.png" alt="截图快捷键设置](Ubuntu 系统安装"></p><p>xkill 快捷键配置， 关闭无响应的程序：<br><img src="Ubuntu-系统安装以及一些开发必要的安装配置/xkill-key.png" alt="xkill 快捷键设置](Ubuntu 系统安装"></p><p>返回桌面快键键配置，换回 window 系统下熟悉的 super + d 快捷键：<br><img src="Ubuntu-系统安装以及一些开发必要的安装配置/super-d.png" alt="返回桌面快捷键设置](Ubuntu 系统安装"></p><p>可能有时返回桌面的快捷键配置后还是没用，super + d 无法返回到桌面，这时需要做以下设置：<br>首先安装 compizconfig-settings-manager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install compizconfig-settings-manager</span><br></pre></td></tr></table></figure><p>然后在终端输入 compizconfig-settings-manager 命令打开该软件，找到 Ubuntu Unity plugin，General 里面有个 Show Desktop，设置一下相应快捷键就可以了。</p><h3 id="Ubuntu-系统微信、QQ、Listen-安装"><a href="#Ubuntu-系统微信、QQ、Listen-安装" class="headerlink" title="Ubuntu 系统微信、QQ、Listen 安装"></a>Ubuntu 系统微信、QQ、Listen 安装</h3><p>微信安装参考 GitHub 上面的一个项目，里面有已经发布好了的，直接下载解压后即可使用，链接如下：</p><p><a href="https://github.com/geeeeeeeeek/electronic-wechat/releases" target="_blank" rel="noopener">GitHub 微信项目链接</a></p><p>QQ 安装参考下面博主写的教程：</p><p><a href="https://blog.csdn.net/ysy950803/article/details/80215101" target="_blank" rel="noopener">Ubuntu 18.04安装最新版QQ（9.0）</a><br><a href="https://blog.csdn.net/qq_36428171/article/details/78244730" target="_blank" rel="noopener">在ubuntu17.04下安装最新版QQ教程</a></p><p>Listen 是一款听音乐的 App，集成了网易，虾米，QQ 音乐，你想听的里面基本上能够搜到，而且界面也很符合我们开发者的风格，可以说很良心了，网站链接：</p><p><a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">Listen 网站链接</a><br>打开该网站下载 Linux 版本即可，他还有浏览器插件版，不想安装的话也可以直接下载浏览器插件版。</p><p>最后如果必须要用到 Windows 系统下面的软件的话，那就只能推荐一款软件给你了：Virtual Box 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install virtualbox</span><br><span class="line">sudo apt-get install virtualbox-guest-additions</span><br><span class="line">sudo apt-get install virtualbox-guest-additions-iso</span><br></pre></td></tr></table></figure><p>使 Virtualbox 辨认出物理 USB 外设</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-system-tools</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于开发人员来说，个人强烈推荐使用 Linux 系统进行开发，至于为什么，这里贴出自己刚开始尝试使用 Linux 系统时看的一个博主写的文章，可以说就是因为看了这位博主的文章才立即决定装上 Linux 系统，开始了我的 Linux 系统之旅，从此停不下来了。下面就是这位博主
      
    
    </summary>
    
      <category term="Linux" scheme="http://gittab.net/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系统下的软链接和硬链接</title>
    <link href="http://gittab.net/Linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5/"/>
    <id>http://gittab.net/Linux-系统下的软链接和硬链接/</id>
    <published>2018-04-25T15:41:50.000Z</published>
    <updated>2018-07-23T13:43:02.921Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直不是很明白 Linux 系统下的软链接 (soft link) 和硬链接 (hard link) 的区别和用法，今天刚好又用到了，特意花了点时间去了解了一下，暂且在这里记录一下吧。</p><p>在介绍硬链接和软链接之前先介绍一下 Linux 系统下面的文件结构，文件在 Linux 下可以分为两个部分：元数据和用户数据。元数据中主要包含文件的一些附加属性，比如：文件大小，创建时间，所有者信息以及 文件的 inode 索引号，inode 索引号是文件索引节点号，也是文件的唯一标识，我们平常看到的文件名并非是用来区分文件而是一个别名便于我们识别和记忆；用户数据则是文件的数据块内容，也就是该文件保存的真正内容。</p><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>(1) 含义<br>硬链接表示的是一个文件的 inode 索引号对应于多个文件名，也就是说我们对一个文件创建了多个文件名，它们都对应于同一个 inode 索引号标识的文件，当我们删除其中任意一个文件名，都不会对其他文件名有影响，每删一个文件名，该文件的链接数减一，只有当该文件的链接数为 0 时系统会将其数据块和 inode 索引号回收。</p><p>(2) 创建方式<br>eg. 为 /root/fileA 创建硬链接 /home/fileB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /root/fileA /home/fileB</span><br></pre></td></tr></table></figure><p>注意：应该使用文件的绝对路径，避免使用相对路径。</p><p>(3) 特性</p><ul><li>文件有相同的 inode 及 data block</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li><li>文件的链接数为 0 时系统会将其数据块和 inode 索引号回收</li></ul><p>(4) 使用限制</p><ul><li>不能对目录创建硬链接，只能对文件创建</li><li>不能对不同的文件系统创建硬链接,即两个文件名要在相同的文件系统下</li><li>只能对已存在的文件进行创建</li></ul><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>(1) 含义<br>软链接其实就是一个普通的文件，有着自己的 inode 索引号和数据块，特殊的是该文件的用户数据块中存放的是另一个文件的路径，有点类似于 Windows 系统中的快捷方式，通过快捷方式可以打开它所指向的文件，链接文件的删除不影响该链接文件数据块存放的路径指向的文件。</p><p>(2) 创建方式<br>eg. 为 /root/fileA 创建软链接 /home/fileB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /root/fileA /home/fileB</span><br></pre></td></tr></table></figure><p>注意：应该使用文件的绝对路径，避免使用相对路径。</p><p>(3) 特性</p><ul><li>软链接有自己的文件属性及权限等</li><li>创建软链接时，链接计数不会增加</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</li></ul><p>(4) 使用限制</p><ul><li>可以跨文件系统创建</li><li>可以对文件或者目录创建</li><li>可以对一个不存在的文件或者目录创建</li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>最后说一下文件的类型主要有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d ：目录   </span><br><span class="line">- ：文件   </span><br><span class="line">l ：链接   </span><br><span class="line">s ：socket   </span><br><span class="line">p ：named pipe   </span><br><span class="line">b ：block device   </span><br><span class="line">c  ：character device</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直不是很明白 Linux 系统下的软链接 (soft link) 和硬链接 (hard link) 的区别和用法，今天刚好又用到了，特意花了点时间去了解了一下，暂且在这里记录一下吧。&lt;/p&gt;
&lt;p&gt;在介绍硬链接和软链接之前先介绍一下 Linux 系统下面的文件结构，文
      
    
    </summary>
    
      <category term="Linux" scheme="http://gittab.net/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 下 MySQL 安装以及配置远程可访问</title>
    <link href="http://gittab.net/Ubuntu-%E4%B8%8B-MySQL-%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E9%85%8D%E7%BD%AE%E5%8F%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <id>http://gittab.net/Ubuntu-下-MySQL-安装以及配置可远程访问/</id>
    <published>2018-04-23T14:15:09.000Z</published>
    <updated>2018-07-23T13:43:03.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu-安装-MySQL"><a href="#Ubuntu-安装-MySQL" class="headerlink" title="Ubuntu 安装 MySQL"></a>Ubuntu 安装 MySQL</h3><p>最好先执行一次更新操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>然后执行以下三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br><span class="line">sudo apt-get isntall mysql-client</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>安装成功后可以通过下面的命令测试是否安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure><p>出现如下信息证明 MySQL 安装成功：<br>​<img src="Ubuntu-下-MySQL-配置远程可访问/mysql.png" alt="mysqld.cnf 文件"></p><p>对于 Ubuntu 系统下安装 MySQL 后一般都不支持远程连接，只能通过 localhost 或者 127.0.0.1 进行连接，因此需要我们自己去配置，这里介绍两种方式：</p><h3 id="创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式"><a href="#创建一个新的访问用户，配置该用户可以远程访问。-推荐使用这种方式" class="headerlink" title="创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)"></a>创建一个新的访问用户，配置该用户可以远程访问。(推荐使用这种方式)</h3><p>(1) 在安装好了 MySQL 数据库之后，由于 MySQL 数据库安装好之后出于安全考虑默认就是只允许通过本机访问，即只能通过 127.0.0.1 或者 localhost 去访问，所以首先需要修改 MySQL 的配置文件，在 Ubuntu 系统下, MySQL 的配置文件在路径 /etc/mysql/mysql.conf.d/ 下,找到该路径下的 mysqld.cnf 文件打开找到如下位置:<br>​<img src="Ubuntu-下-MySQL-配置远程可访问/mysqld.cnf.png" alt="mysqld.cnf 文件"></p><p>红色标注部分这里就是 MySQL 默认只能由本机访问，我们将其注释掉。注释之后最好将服务重启，之后再进行创建用户以及赋予相应权限的操作。</p><p>(2) 在本机使用 root 用户登录到 MySQL 数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>回车后输入密码登录。<br>(3) 创建用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user username identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure><p>username 是你要创建的用户名，password 为密码。</p><p>(4) 给创建的用户添加权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &apos;username&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;</span><br></pre></td></tr></table></figure><p>上面的 all 代表接受所有操作，比如 select,insert,delete….;  <em>.</em> 代表所有数据库下面的所有表，也就是所有权限;而 % 代表这个用户允许从任何地方登录；为了安全期间，这个 % 可以替换为你允许的 ip 地址。username  表示你要赋予权限的用户名，password 表示该用户名对应的密码。</p><p>(5) 修改后刷新权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>(6) 执行完上面的操作后，输入 quit 命令退出数据库将 MySQL 服务重启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure><p>(7) 重启之后用刚才创建好的用户并且使用本机的 IP 地址进行测试，输入如下命令登录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u username -p</span><br></pre></td></tr></table></figure><p>192.168.0.161 表示 MySQL 服务所在机器的 IP 地址，username 为刚才新创建的用户名，回车后输入密码，再回车登录成功表示配置已经生效了。否则需要再检查一遍其他哪里没有配置好。</p><h3 id="修改当前-root-用户的配置，使该用户可以远程访问"><a href="#修改当前-root-用户的配置，使该用户可以远程访问" class="headerlink" title="修改当前 root 用户的配置，使该用户可以远程访问"></a>修改当前 root 用户的配置，使该用户可以远程访问</h3><p>同样的先执行第一种方式中步骤一和步骤二，然后执行以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;password&apos; with grant option;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>之后将 MySQL 服务重启，重启之后用 root 用户通过 IP 地址登录测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 192.168.0.161 -u root -p</span><br></pre></td></tr></table></figure><p>两种方式本质是一样的，只不过第二种更省事，直接在已有的 root 用户上进行更改，但这样不是很安全，所以推荐第一种方式，配置权限时可以指定一些权限，也可以指定 IP 地址可远程访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Ubuntu-安装-MySQL&quot;&gt;&lt;a href=&quot;#Ubuntu-安装-MySQL&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 安装 MySQL&quot;&gt;&lt;/a&gt;Ubuntu 安装 MySQL&lt;/h3&gt;&lt;p&gt;最好先执行一次更新操作：&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="MySQL" scheme="http://gittab.net/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 执行命令时报错 unable to resolve host</title>
    <link href="http://gittab.net/Ubuntu-%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99-unable-to-resolve-host/"/>
    <id>http://gittab.net/Ubuntu-执行命令时报错-unable-to-resolve-host/</id>
    <published>2018-04-08T14:26:03.000Z</published>
    <updated>2018-07-23T13:43:02.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录一下今天遇到的一个问题"><a href="#记录一下今天遇到的一个问题" class="headerlink" title="记录一下今天遇到的一个问题"></a>记录一下今天遇到的一个问题</h2><p>今天在阿里云服务器上部署应用时遇到一个小问题，每次执行完 sudo 命令都会出现一行错误信息，刚开始还以为执行命令出错了，但仔细一看不像是执行命令的报错信息，而且还发现命令其实已经执行成功了。</p><p>执行命令之后的报错信息如下：</p><p><img src="Ubuntu-执行命令时报错-unable-to-resolve-host/resolve host3.png" alt="hosts 文件"></p><p>于是去百度了一波，发现原来是<strong><em>因为 /etc/ 路径下 hosts 文件中的主机名和 hostname 文件中的主机名不一致</em></strong>所导致的错误。</p><p>经查看 hostname 文件中的主机名如下：</p><p><img src="Ubuntu-执行命令时报错-unable-to-resolve-host/resolve host5.png" alt="hosts 文件"></p><p>知道原因了之后就知道如何解决了，方式如下:</p><p>在 /etc/ 路径下 hosts 文件中添加一行，将 /etc/ 路径下 hostname 文件中的主机名称拷贝过来即可，hosts 文件修改之后如下：</p><p><img src="Ubuntu-执行命令时报错-unable-to-resolve-host/resolve host4.png" alt="hosts 文件"></p><p>以下则分别是我电脑上 /etc 路径下 hosts 文件和 hostname 文件中的内容</p><p><img src="Ubuntu-执行命令时报错-unable-to-resolve-host/resolve host.png" alt="hosts 文件"></p><p><img src="Ubuntu-执行命令时报错-unable-to-resolve-host/resolve host2.png" alt="hostname 文件"></p><p>比如上面我电脑上 hostname 文件中内容是 zhouoxh-X550VC ，只要在 hosts 文件中添加一行 127.0.1.1       zhouxh-X550VC，如果不加这一行执行 sudo 命令就会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;记录一下今天遇到的一个问题&quot;&gt;&lt;a href=&quot;#记录一下今天遇到的一个问题&quot; class=&quot;headerlink&quot; title=&quot;记录一下今天遇到的一个问题&quot;&gt;&lt;/a&gt;记录一下今天遇到的一个问题&lt;/h2&gt;&lt;p&gt;今天在阿里云服务器上部署应用时遇到一个小问题，每次执
      
    
    </summary>
    
      <category term="Linux" scheme="http://gittab.net/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 面试系列——基础篇(二)</title>
    <link href="http://gittab.net/Java-%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%AF%87-%E4%BA%8C/"/>
    <id>http://gittab.net/Java-面试系列——基础篇-二/</id>
    <published>2018-04-01T10:56:13.000Z</published>
    <updated>2018-07-23T13:43:02.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-中-equals-与-的区别"><a href="#Java-中-equals-与-的区别" class="headerlink" title="Java 中 equals 与 == 的区别"></a>Java 中 equals 与 == 的区别</h2><p>通俗的来说，“==” 比较的是地址，equals 比较的是内容。也就是说前者比较的是对象(堆)在(栈)内存中存放的内存地址，用来判断两个对象的地址是否相同，即是否是指向同一个对象。后者用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object 类的，所以适用于所有对象，注意如果没有对该方法进行重写的话，调用的仍然是 Object 类中的方法，而 Object 中的 equals 方法返回的却是内存地址比较的结果，方法内容如下 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashCode-和-equals-方法的区别与联系"><a href="#hashCode-和-equals-方法的区别与联系" class="headerlink" title="hashCode 和 equals 方法的区别与联系"></a>hashCode 和 equals 方法的区别与联系</h2><p>hashCode 和 equals 方法都是 Object 中的方法，其中 hashCode 方法是 Native 修饰，该方法是计算出对象实例的哈希码，又称哈希函数，计算方式依赖于对象实例的内存地址，所以一般来说，每个对象实例的哈希码都是唯一的，当然如果对该方法进行重写了，结果也就不一样了。而 equals 方法一般是用来比较两个对象实例的值是否相等，当然如果没有对该方法进行重写，比较的就是两个对象的地址是否相等。</p><p>他们之间的联系就是当两个对象的 equals 相等那么 hashCode 一定相等，hashCode 不等那么equals 一定不等。反之 hashCode 相等，equals 不一定相等，因为哈希散列值有冲突的时候，当然好的哈希算法冲突的几率比较小。</p><p>其次在我们开发当中，一般都会同时对这两个方法进行重写，如果只重写其中一个或者都不重写当我们将这个对象放入 Map 集合或者 Set 集合中时就会出问题了。如果只重写了 hashCode 方法没有重写 equals 方法，那么就会出现 hashCode 值相同时，这时找到数组同一个位置的元素链表，由于没有重写 equals 方法导致向 Map 中取元素时找不到你要找的元素；当向 Map 集合中放入元素时就会放入重复的元素，因为此时比较的是两个元素的内存地址。如果只重写了 equals 方法没有重写 hashCode 方法，当你向 Map 中获取元素时，第一步比较 hashCode 值时就已经不等，所以也就找不到你想要找的元素了；当你向 Map 中放入元素时，第一步比较就始终定位在数组的不同的位置，这样也就达不到覆盖 key 值相同的元素，Set 集合也达不到去重的效果了。</p><p>还有就是对于需要大量并且快速的对比的话如果都用 equals 方法做比较显然效率太低，所以解决方式是每当需要对比的时候，首先用 hashCode 方法进行对比，如果hashCode 不一样，则表示这两个对象肯定不相等（也就是不必再用 equals 对比了），如果 hashCode 相同，此时再通过 equals 方法对比，如果 equals 也相同则表示这两个对象是真的相同了，这样既能大大提高效率也保证对比的绝对正确性！</p><p><strong><em>总之，这两个方法对实现 HashMap 的精确性和正确性，以及对 Set 集合中去重功能的实现至关重要，以下 String 类中的 hashCode 方法和 equals 方法：</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">int h = hash;</span><br><span class="line">if (h == 0 &amp;&amp; value.length &gt; 0) &#123;</span><br><span class="line">    char val[] = value;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; value.length; i++) &#123;</span><br><span class="line">        h = 31 * h + val[i];</span><br><span class="line">    &#125;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br><span class="line">return h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>public boolean equals(Object anObject) {    if (this == anObject) {        return true;    }    if (anObject instanceof String) {        String anotherString = (String)anObject;        int n = value.length;        if (n == anotherString.value.length) {            char v1[] = value;            char v2[] = anotherString.value;            int i = 0;            while (n-- != 0) {                if (v1[i] != v2[i])                    return false;                i++;            }            return true;        }    }    return false;}</code></pre><h2 id="什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用"><a href="#什么是-Java-序列化和反序列化，如何实现-Java-序列化？或者请解释-Serializable-接口的作用" class="headerlink" title="什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用"></a>什么是 Java 序列化和反序列化，如何实现 Java 序列化？或者请解释 Serializable 接口的作用</h2><p>序列化就是一种用来处理对象流的机制,所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间，序列化是为了解决在对对象流进行读写操作时所引发的问题。反序列话则刚好相反，将流化后的对象重新恢复成对象状态就称为反序列化。<br>序列化的实现:将需要被序列化的类实现 Serializable 接口,该接口没有需要实现的方法，实现 Serializable 接口只是为了标注该对象是可被序列化的，然后使用一个输出流(如:FileOutputStream)来构造一个 ObjectOutputStream (对象流)对象，接着使用ObjectOutputStream 对象的 writeObject(Object obj) 方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则使用输入流。</p><h2 id="Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？"><a href="#Object-类中常见的方法，为什么-wait-notify-会放在-Object-里边？" class="headerlink" title="Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？"></a>Object 类中常见的方法，为什么 wait notify 会放在 Object 里边？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;&#125;</span><br><span class="line">public boolean equals(Object obj) &#123;&#125;</span><br><span class="line">public native int hashCode();</span><br><span class="line">protected void finalize() throws Throwable &#123;&#125;</span><br><span class="line">public final native Class&lt;?&gt; getClass();</span><br><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br><span class="line">public final void wait() throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;</span><br><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br><span class="line">private static native void registerNatives();</span><br></pre></td></tr></table></figure><p>以上便是 Object 类中所有的方法，其中 toString(), equals(), hashCode() 三个方法是我们见的相对较多的，finalize() 这个方法是由垃圾收集器在确定这个对象没有被引用时在释放对象占用的内存之前会调用该方法，clone() 方法是给对象创建一个自己的副本，前提是对象已经实现了 Cloneable 接口，否则抛出 CloneNotSupportedException，getClass() 方法返回此对象的运行时类型。</p><p>wait 有三个重载方法，同时必须捕获非运行时异常 InterruptedException。</p><ul><li>wait() 进入等待，需要 notify()，notifyAll() 才能唤醒</li><li>wait(long timeout) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒</li><li>wait(timeout, nanos) 进入等待，经过 timeout 超时后，若未被唤醒，则自动唤醒。相对 wait(long timeout) 时间更加精确。</li></ul><p>wait() 和 notify() 以及 notifyAll() 则是用来控制线程的状态的，它们必须在 synchronized 同步关键字所限定的作用域中调用，否则会报错 java.lang.IllegalMonitorStateException，意思是因为没有同步，所以线程对象锁的状态是不确定的，不能调用这些方法。同时 synchronized 关键字锁可以是任意对象，任意对象调用的方法则一定是定义在 Object 类中。</p><ul><li>wait 表示持有对象锁的线程准备释放对象锁，释放资源并进入等待状态，直到它被其他线程通过 notify() 或者 notifyAll() 唤醒。</li><li><p>notify 表示持有对象锁的线程准备释放对象锁，调用 notify() 通知 JVM 随机选择一个在该对象上调用 wait() 方法的线程，解除其阻塞状态使其获得对象锁，synchronized 代码作用域结束后，随机选择的那个线程获得对象锁，其他调用 wait() 方法的线程继续等待，直到有新的 notify() 或者 notifyAll() 被调用。</p></li><li><p>notifyAll 表示持有对象锁的线程准备释放对象锁，调用 notifyAll() 通知 JVM 唤醒所有在该对象上调用 wait() 方法的线程的阻塞状态, synchronized 代码作用域结束后，JVM 通过算法将对象锁指派给其中一个线程，当前获得对象锁的线程 synchronized 代码作用域结束后，然后所有被唤醒的线程不再等待，之前所有被唤醒的线程都有可能获得该对象锁权限，这个由 JVM 算法决定。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-中-equals-与-的区别&quot;&gt;&lt;a href=&quot;#Java-中-equals-与-的区别&quot; class=&quot;headerlink&quot; title=&quot;Java 中 equals 与 == 的区别&quot;&gt;&lt;/a&gt;Java 中 equals 与 == 的区别&lt;/h2
      
    
    </summary>
    
      <category term="面试系列" scheme="http://gittab.net/categories/%E9%9D%A2%E8%AF%95%E7%B3%BB%E5%88%97/"/>
    
    
  </entry>
  
</feed>
